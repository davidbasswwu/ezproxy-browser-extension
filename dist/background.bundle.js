let o=null,t=new Set;const e=new Map;async function n(){try{const t=chrome.runtime.getURL("config.json"),e=await fetch(t);if(!e.ok)throw new Error(`Failed to load configuration: ${e.status}`);const n=await e.json(),r=["domainListUrl","ezproxyBaseUrl","institutionName","bannerMessage","updateInterval","retryAttempts","retryDelay","enableAutoRedirect","enableUserNotifications"].filter((o=>void 0===n[o]));if(r.length>0)throw new Error(`Missing required configuration fields: ${r.join(", ")}`);if("number"!=typeof n.updateInterval||n.updateInterval<6e4)throw new Error("updateInterval must be a number >= 60000ms (1 minute)");if("number"!=typeof n.retryAttempts||n.retryAttempts<0)throw new Error("retryAttempts must be a non-negative number");if("number"!=typeof n.retryDelay||n.retryDelay<0)throw new Error("retryDelay must be a non-negative number");return o=n,console.log("Configuration loaded successfully"),!0}catch(o){throw console.error("Error loading configuration:",o),o}}async function r(){try{const n=await chrome.storage.local.get(["domainList","lastUpdate"]);if(n.domainList&&Array.isArray(n.domainList)){t=new Set(n.domainList),console.log(`Domain list loaded from storage (${t.size} domains)`);const e=Date.now(),r=e-(n.lastUpdate||0);if(r<o.updateInterval)return void console.log(`Domain list is up to date (last updated ${Math.round(r/1e3/60)} minutes ago)`)}console.log("Fetching remote domain list from:",o.domainListUrl);const r=await async function(t,e=o.retryAttempts,n=o.retryDelay){let r;for(let o=1;o<=e;o++)try{const o=await fetch(t);if(!o.ok)throw new Error(`HTTP ${o.status}: ${o.statusText}`);return o}catch(t){if(r=t,console.log(`Fetch attempt ${o}/${e} failed:`,t.message),o<e){const t=n*Math.pow(2,o-1);console.log(`Retrying in ${t}ms...`),await new Promise((o=>setTimeout(o,t)))}}throw r}(o.domainListUrl,o.retryAttempts,o.retryDelay);if(!r.ok)throw new Error(`HTTP ${r.status}: ${r.statusText}`);const a=await r.json();if(!Array.isArray(a))throw new Error("Remote domain list is not an array");const i=a.filter((o=>"string"==typeof o&&o.length>0)).map((o=>o.toLowerCase().trim())).filter((o=>{try{return new URL(o.startsWith("http")?o:`https://${o}`),!0}catch{return console.warn(`Invalid domain format: ${o}`),!1}}));if(0===i.length)throw new Error("No valid domains found in the domain list");return t=new Set(i),await chrome.storage.local.set({domainList:Array.from(t),lastUpdate:Date.now()}),e.clear(),console.log(`Domain list updated successfully (${t.size} domains)`),!0}catch(o){if(console.error("Error updating domain list:",o),0===t.size){console.log("Attempting to load local domain list as fallback...");try{const o=await async function(){try{const o=chrome.runtime.getURL("domain-list.json"),t=await fetch(o);if(!t.ok)throw new Error(`Failed to load local domain list: ${t.status}`);const e=await t.json();if(!Array.isArray(e))throw new Error("Domain list must be an array");return new Set(e.filter((o=>"string"==typeof o&&o.length>0)))}catch(o){return console.error("Error loading local domain list:",o),new Set}}();if(o.size>0)return t=o,console.log(`Loaded ${o.size} domains from local fallback`),!0}catch(o){console.error("Error loading local domain list:",o)}throw console.error("CRITICAL: No domain list available (local or remote)"),new Error("No domain list available. Please check your internet connection and try again.")}return console.log(`Using existing domain list (${t.size} domains)`),!1}}function a(t,n){try{const r=new URL(t),a=function(o){if(e.has(o))return e.get(o);const t=o.replace(/\./g,"-");return e.set(o,t),t}(n),i=`${r.protocol}//${a}.${o.ezproxyBaseUrl}${r.pathname}${r.search}${r.hash}`;return new URL(i),i}catch(o){return console.error("Error building EZProxy URL:",o),null}}let i;async function s(){console.log("Testing icon update functionality...");const o=await chrome.tabs.query({active:!0,currentWindow:!0});if(o&&o[0]&&o[0].id){const t=o[0].id;console.log(`Found active tab: ${t}`);try{console.log("Setting dismissed icon..."),await c(t,!0),console.log("Dismissed icon set successfully"),setTimeout((async()=>{console.log("Resetting to normal icon..."),await c(t,!1),console.log("Normal icon restored")}),3e3)}catch(o){console.error("Error testing icon update:",o)}}else console.error("No active tab found for testing")}async function c(o,t){console.log(`[updateExtensionIcon] Updating icon for tab ${o}, isDismissed: ${t}`);const e=(o,t=!1)=>chrome.runtime.getURL(`images/icon${t?"-dismissed":""}-${o}.png`),n={16:e(16,t),32:e(32,t),48:chrome.runtime.getURL("images/icon-48.png"),128:chrome.runtime.getURL("images/icon-128.png")};console.log("Using icon paths:",n),console.log("[updateExtensionIcon] Using icon paths:",n);const r=t?"EZProxy: Banner is dismissed for this domain":"EZProxy: Click to access library resources";try{if(o){console.log(`[updateExtensionIcon] Updating icon for specific tab ${o}`);try{return await chrome.action.setIcon({tabId:o,path:n}),console.log(`[updateExtensionIcon] Successfully updated tab ${o} icon`),await chrome.action.setTitle({tabId:o,title:r}),console.log(`[updateExtensionIcon] Set title for tab ${o}: ${r}`),await chrome.action.setBadgeText({tabId:o,text:t?"X":""}),void await chrome.action.setBadgeBackgroundColor({tabId:o,color:t?"#dc3545":[0,0,0,0]})}catch(t){console.error(`[updateExtensionIcon] Error updating tab ${o} icon:`,t)}}console.log("[updateExtensionIcon] Updating global icon"),await chrome.action.setIcon({tabId:void 0,path:n}),await chrome.action.setTitle({tabId:void 0,title:r}),console.log("[updateExtensionIcon] Successfully updated global icon and title")}catch(o){throw console.error("[updateExtensionIcon] Error in updateExtensionIcon:",o),o}}chrome.tabs.onUpdated.addListener((async(o,t,e)=>{if("complete"===t.status&&e.url)try{const t=new URL(e.url).hostname,n=(await chrome.tabs.get(o),await chrome.storage.local.get("ezproxy-dismissed-domains")),r=(n["ezproxy-dismissed-domains"]||[]).some((o=>t.endsWith(o)||t===o));await c(o,r)}catch(o){console.error("Error in tab update listener:",o)}})),chrome.runtime.onMessage.addListener(((t,e,r)=>(console.log("Received message in background:",t.action||"unknown action",t),"updateIcon"===t.action?(c(t.tabId,t.isDismissed).then((()=>r({success:!0}))).catch((o=>{console.error("Error updating icon:",o),r({success:!1,error:o.message})})),!0):"dismissDomain"===t.action?(console.log("Handling dismissDomain for domain:",t.domain),chrome.tabs.query({active:!0,currentWindow:!0},(o=>{o&&o[0]&&o[0].id?(console.log("Updating icon for tab:",o[0].id),c(o[0].id,!0).then((()=>{console.log("Icon updated successfully after domain dismissal"),r({success:!0})})).catch((o=>{console.error("Error updating icon after domain dismissal:",o),r({success:!1,error:o.message})}))):(console.warn("No active tab found to update icon"),r({success:!1,error:"No active tab found"}))})),!0):"getTab"===t.action?(chrome.tabs.query({active:!0,currentWindow:!0},(o=>{r(o)})),!0):"getTabId"===t.action?(r({tabId:e.tab?e.tab.id:null}),!0):"GET_CONFIG"===t.type?(o?r({config:o}):n().then((()=>r({config:o}))).catch((o=>{console.error("Error loading config for content script:",o),r({error:"Failed to load configuration"})})),!0):(console.warn("Unhandled message in background script:",t),!1)))),async function(){try{console.log("Initializing EZProxy extension..."),await n(),await r(),setInterval(r,o.updateInterval),console.log(`Scheduled domain list updates every ${o.updateInterval/1e3/60} minutes`),console.log("EZProxy extension initialized successfully"),setTimeout(s,1e3)}catch(o){throw console.error("Fatal error initializing extension:",o),o}}(),chrome.tabs.onUpdated.addListener(((e,n,r)=>{"complete"===n.status&&r.url&&(r.url.startsWith("http://")||r.url.startsWith("https://"))&&function(o,t=100){clearTimeout(i),i=setTimeout(o,t)}((()=>{try{const n=new URL(r.url),i=n.hostname.replace(/^www\./,"");let s=null;if(t.has(i))s=i;else for(const o of t)if(i.endsWith("."+o)){s=o;break}if(s){console.log("Domain matches tracking list:",s,"for URL:",r.url);const t=a(r.url,s);if(!t)return void console.error("Failed to build EZProxy URL for:",s);const n=(a=0)=>{chrome.tabs.sendMessage(e,{type:"DOMAIN_MATCH",domain:s,originalUrl:r.url,ezproxyUrl:t,bannerMessage:o.bannerMessage}).catch((o=>{o.message.includes("Receiving end does not exist")&&a<3?(console.log(`Content script not ready, retrying in ${500*(a+1)}ms (attempt ${a+1}/3)`),setTimeout((()=>n(a+1)),500*(a+1))):o.message.includes("Receiving end does not exist")||console.error("Error sending message to content script:",o)}))};n()}}catch(o){console.error("Error processing URL:",o)}}))}));
//# sourceMappingURL=background.bundle.js.map