{"version":3,"file":"content.bundle.js","mappings":"AAGA","sources":["webpack://ezproxy-extension/./content.js"],"sourcesContent":["// content.js\n\n// Constants\nconst BANNER_ID = 'ezproxy-banner';\nconst SECONDARY_BANNER_ID = 'ezproxy-secondary-banner';\nconst STORAGE_KEYS = {\n    DISMISSED_DOMAINS: 'ezproxy-dismissed-domains',\n    AUTO_REDIRECT: 'ezproxy-auto-redirect'\n};\n\n// Icon paths\nconst ICON_PATHS = {\n    NORMAL: {\n        '16': 'images/icon-16.png',\n        '48': 'images/icon-48.png',\n        '128': 'images/icon-128.png'\n    },\n    DISMISSED: {\n        '16': 'images/icon-dismissed-16.png',\n        '48': 'images/icon-48.png',  // Using normal icon for larger sizes\n        '128': 'images/icon-128.png'  // Using normal icon for larger sizes\n    }\n};\n\n// Global variable to track if we've initialized\nlet isInitialized = false;\n\n// Check if user has reduced motion preference\nconst prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;\n\n// Cache for configuration\nlet configCache = null;\n/**\n * Gets the current configuration from the background script\n * @returns {Promise<Object>} The configuration object\n */\nasync function getConfig() {\n    // Return cached config if available\n    if (configCache) {\n        return configCache;\n    }\n    \n    try {\n        // Request configuration from background script\n        const response = await chrome.runtime.sendMessage({ type: 'GET_CONFIG' });\n        if (response && response.config) {\n            configCache = response.config;\n            return configCache;\n        }\n        throw new Error('Invalid configuration received');\n    } catch (error) {\n        console.error('Failed to load configuration:', error);\n        // Return a minimal safe default config\n        return {\n            institutionName: 'Institution',\n            accessIndicators: ['access provided by', 'authenticated via', 'logged in as'],\n            bannerMessage: 'This resource is available through your institution. Access the full content via EZProxy.'\n        };\n    }\n}\n\n/**\n * Gets the domain list from the local file\n * @returns {Promise<Array>} Array of domains\n */\nasync function getDomainList() {\n    try {\n        console.log('Fetching domain list...');\n        const url = chrome.runtime.getURL('domain-list.json');\n        console.log('Domain list URL:', url);\n        \n        const response = await fetch(url);\n        \n        if (!response.ok) {\n            throw new Error(`Failed to fetch domain list: ${response.status} ${response.statusText}`);\n        }\n        \n        const contentType = response.headers.get('content-type');\n        if (!contentType || !contentType.includes('application/json')) {\n            console.warn('Unexpected content type:', contentType);\n        }\n        \n        const data = await response.json();\n        console.log('Domain list loaded successfully, entries:', data.length);\n        return Array.isArray(data) ? data : [];\n    } catch (error) {\n        console.error('Error loading domain list:', error);\n        // Try to load a backup list from storage\n        try {\n            const result = await chrome.storage.local.get('ezproxy-domain-list-backup');\n            const backupList = result['ezproxy-domain-list-backup'];\n            console.log('Using backup domain list from storage:', backupList ? backupList.length : 0, 'entries');\n            return Array.isArray(backupList) ? backupList : [];\n        } catch (storageError) {\n            console.error('Failed to load backup domain list:', storageError);\n            return [];\n        }\n    }\n}\n\n/**\n * Checks if the current page indicates institutional access\n * @param {Object} config - The configuration object\n * @returns {boolean} True if institutional access is detected\n */\nasync function hasInstitutionalAccess(config) {\n    console.log('[hasInstitutionalAccess] Checking if user has institutional access');\n    \n    if (!config) {\n        console.warn('[hasInstitutionalAccess] No config provided');\n        return false;\n    }\n    \n    // Get current domain to check for special cases\n    const currentHostname = window.location.hostname.toLowerCase();\n    \n    // IMPORTANT: For Nature and Chronicle, we'll return false to ensure the banner shows\n    // This is a temporary fix to ensure consistent banner display\n    if (currentHostname.includes('nature.com') || currentHostname.includes('chronicle.com')) {\n        console.log(`[hasInstitutionalAccess] Special case for ${currentHostname}: forcing banner display`);\n        return false;\n    }\n    \n    // Enhanced page text extraction with multiple methods\n    let pageText = '';\n    \n    try {\n        // Method 1: Direct textContent extraction\n        pageText = document.body?.textContent || document.documentElement?.textContent || '';\n        \n        // Method 2: If text is empty or very short, try getting text from main content areas\n        if (!pageText || pageText.length < 100) {\n            console.log('[hasInstitutionalAccess] Direct text extraction yielded limited content, trying content areas');\n            const contentSelectors = [\n                'main', 'article', '.content', '.article', '#content', '#main', \n                '[role=\"main\"]', '[role=\"article\"]', '.page-content'\n            ];\n            \n            for (const selector of contentSelectors) {\n                const elements = document.querySelectorAll(selector);\n                if (elements && elements.length > 0) {\n                    for (const element of elements) {\n                        pageText += ' ' + (element.textContent || '');\n                    }\n                }\n            }\n        }\n        \n        // Method 3: If still empty, try getting text from all paragraphs\n        if (!pageText || pageText.length < 100) {\n            console.log('[hasInstitutionalAccess] Content area extraction yielded limited content, trying paragraphs');\n            const paragraphs = document.querySelectorAll('p');\n            if (paragraphs && paragraphs.length > 0) {\n                for (const p of paragraphs) {\n                    pageText += ' ' + (p.textContent || '');\n                }\n            }\n        }\n        \n        // Clean up the text\n        pageText = pageText.trim();\n    } catch (error) {\n        console.error('[hasInstitutionalAccess] Error extracting page text:', error);\n    }\n    \n    if (!pageText) {\n        console.warn('[hasInstitutionalAccess] Could not get page text after multiple extraction attempts');\n        // Don't return false immediately - continue with other checks\n    }\n    \n    // Get institution details from config with defaults\n    const instName = (config.institutionName || 'Institution').toLowerCase();\n    const configDomain = (config.institutionDomain || 'example.edu').toLowerCase();\n    const shortName = (config.institutionShortName || '').toLowerCase();\n    const libraryName = (config.institutionLibraryName || '').toLowerCase();\n    \n    console.log('[hasInstitutionalAccess] Using institution:', instName, 'domain:', configDomain);\n    \n    // Special case for Financial Times (ft.com)\n    if (currentHostname.includes('ft.com')) {\n        console.log('[hasInstitutionalAccess] Financial Times website detected, performing detailed check');\n        \n        // Check if we need to wait for content to load\n        const needsDelay = !pageText || pageText.length < 1000;\n        if (needsDelay) {\n            console.log('[hasInstitutionalAccess] FT content may not be fully loaded, adding delay checks');\n            \n            // Set a flag in sessionStorage to prevent infinite loops\n            const checkCount = parseInt(sessionStorage.getItem('ft-check-count') || '0');\n            if (checkCount < 3) { // Limit to 3 attempts\n                // Increment the counter\n                sessionStorage.setItem('ft-check-count', (checkCount + 1).toString());\n                \n                // Set a timeout to check again after content has had time to load\n                setTimeout(() => {\n                    console.log(`[hasInstitutionalAccess] Retrying FT check (attempt ${checkCount + 1}/3)`);\n                    // Force a recheck\n                    hasInstitutionalAccess(config);\n                }, 1500); // 1.5 second delay\n                \n                // Return false for now, the timeout will trigger another check\n                return false;\n            } else {\n                // Reset the counter after 3 attempts\n                sessionStorage.removeItem('ft-check-count');\n                console.log('[hasInstitutionalAccess] Maximum FT check attempts reached, proceeding with current content');\n            }\n        } else {\n            // Content seems to be loaded, reset the counter\n            sessionStorage.removeItem('ft-check-count');\n        }\n        \n        // Check for specific FT access elements\n        const ftAccessIndicators = [\n            // Check for subscription/access buttons that indicate no institutional access\n            { selector: '.o-header__top-link--subscribe', negative: true, description: 'Subscribe button' },\n            { selector: '.o-header__top-button--primary', negative: true, description: 'Sign In button' },\n            { selector: '.o-banner__outer', negative: true, description: 'Subscription banner' },\n            { selector: '.n-messaging-banner', negative: true, description: 'Messaging banner' },\n            { selector: '.n-messaging-banner__content', negative: true, description: 'Messaging banner content' },\n            { selector: '.o-message', negative: true, description: 'Message component' },\n            { selector: '.o-message__content-main', negative: true, description: 'Message content' },\n            { selector: '.o-message__actions', negative: true, description: 'Message actions' },\n            \n            // Check for elements that indicate institutional access\n            { selector: '.n-myft-ui--follow', negative: false, description: 'MyFT follow button (requires access)' },\n            { selector: '.article__content', negative: false, description: 'Full article content' },\n            { selector: '.n-content-body', negative: false, description: 'Article body content' },\n            { selector: '.article-body', negative: false, description: 'Article body' },\n            { selector: '.js-article__content', negative: false, description: 'JS article content' },\n            { selector: '.js-article-body', negative: false, description: 'JS article body' },\n            { selector: '.article__content-body', negative: false, description: 'Article content body' }\n        ];\n        \n        let hasAccess = false;\n        let noAccess = false;\n        \n        for (const indicator of ftAccessIndicators) {\n            const elements = document.querySelectorAll(indicator.selector);\n            if (elements && elements.length > 0) {\n                console.log(`[hasInstitutionalAccess] Found FT ${indicator.description}: ${elements.length} elements`);\n                \n                if (indicator.negative) {\n                    // If this is a negative indicator (like subscribe button), it suggests no access\n                    noAccess = true;\n                } else {\n                    // If this is a positive indicator, it suggests access\n                    hasAccess = true;\n                }\n            }\n        }\n        \n        // Check for paywall messaging\n        const paywallText = [\n            'subscribe to read', \n            'to continue reading', \n            'premium content', \n            'subscribe to the ft',\n            'subscribe to continue reading',\n            'start your trial',\n            'free trial',\n            'sign up to',\n            'sign in to',\n            'subscription required',\n            'please subscribe',\n            'for unlimited access',\n            'to unlock this article',\n            'to access this article',\n            'already a subscriber? sign in',\n            'already a subscriber? log in'\n        ];\n        \n        const hasPaywall = paywallText.some(text => {\n            const found = pageText.toLowerCase().includes(text);\n            if (found) {\n                console.log(`[hasInstitutionalAccess] Found FT paywall text: \"${text}\"`);\n                return true;\n            }\n            return false;\n        });\n        \n        if (hasPaywall) {\n            console.log('[hasInstitutionalAccess] Detected paywall content on FT');\n            noAccess = true;\n        }\n        \n        // If we have clear indicators of access, return true\n        if (hasAccess && !noAccess) {\n            console.log('[hasInstitutionalAccess] Detected institutional access on FT based on page elements');\n            return true;\n        }\n    }\n    \n    // Check for common indicators of institutional access\n    const accessIndicators = [\n        // Generic access indicators\n        'access provided by',\n        'authenticated via',\n        'logged in as',\n        'institutional access',\n        'institution=',\n        `institution=${instName}`,\n        `institution=${configDomain}`,\n        // Institution-specific indicators (from config)\n        instName,\n        configDomain,\n        shortName,\n        // Generic full access indicators\n        'you have full access',\n        'full access available',\n        'access to full text'\n    ];\n    \n    // Add institution-specific phrases\n    if (instName) {\n        accessIndicators.push(`site license access provided by ${instName}`);\n    }\n    \n    // Add library name if available\n    if (libraryName) {\n        accessIndicators.push(libraryName);\n    } else if (instName) {\n        // Fallback to institution name + libraries\n        accessIndicators.push(`${instName} libraries`);\n    }\n    \n    // Add any custom indicators from config\n    if (Array.isArray(config.accessIndicators)) {\n        accessIndicators.push(...config.accessIndicators.map(i => i.toLowerCase()));\n    }\n    \n    // Add full access indicators from config\n    if (Array.isArray(config.fullAccessIndicators)) {\n        accessIndicators.push(...config.fullAccessIndicators.map(i => i.toLowerCase()));\n    }\n    \n    // Log what we're checking for\n    console.log('[hasInstitutionalAccess] Checking page for indicators:', accessIndicators);\n    \n    // Convert page text to lowercase once for case-insensitive search\n    const normalizedPageText = pageText.toLowerCase();\n    console.log('[hasInstitutionalAccess] Page text sample (first 500 chars):', \n        normalizedPageText.substring(0, 500).replace(/\\s+/g, ' ').trim() + '...');\n    \n    // Check for access indicators in page text\n    const foundIndicators = [];\n    const hasIndicator = accessIndicators.some(indicator => {\n        if (!indicator) return false;\n        const found = normalizedPageText.includes(indicator.toLowerCase());\n        if (found) {\n            foundIndicators.push(indicator);\n            return true;\n        }\n        return false;\n    });\n    \n    if (foundIndicators.length > 0) {\n        console.log('[hasInstitutionalAccess] Found access indicators:', foundIndicators);\n        return true;\n    }\n    \n    // Additional check for EZProxy elements in the page\n    const ezproxyElements = [\n        ...Array.from(document.querySelectorAll('a[href*=\"ezproxy\" i]')),\n        ...Array.from(document.querySelectorAll('a[href*=\"proxy\" i]')),\n        ...Array.from(document.querySelectorAll('*')).filter(el => {\n            const text = el.textContent?.toLowerCase() || '';\n            return text.includes('ezproxy') || \n                   text.includes('proxy login') ||\n                   text.includes('institutional login');\n        })\n    ];\n    \n    if (ezproxyElements.length > 0) {\n        console.log(`[hasInstitutionalAccess] Found ${ezproxyElements.length} EZProxy related elements`);\n        return true;\n    }\n    \n    // Check for access denied or login required pages\n    const deniedIndicators = [\n        'access denied',\n        'login required',\n        'sign in',\n        'log in',\n        'authentication required',\n        'institutional access required'\n    ];\n    \n    const isDeniedPage = deniedIndicators.some(indicator => \n        normalizedPageText.includes(indicator)\n    );\n    \n    if (isDeniedPage) {\n        console.log('[hasInstitutionalAccess] Detected access denied/login page');\n        return false;\n    }\n    \n    console.log('[hasInstitutionalAccess] No institutional access indicators found');\n    return false;\n}\n\nasync function isDomainDismissed(domain) {\n    try {\n        console.log('Checking if domain is dismissed:', domain);\n        const result = await chrome.storage.local.get(STORAGE_KEYS.DISMISSED_DOMAINS);\n        const dismissedDomains = result[STORAGE_KEYS.DISMISSED_DOMAINS] || [];\n        console.log('Current dismissed domains:', dismissedDomains);\n        \n        // Check if the domain matches any in the dismissed list\n        // using the same logic as in popup.js\n        const isDismissed = dismissedDomains.some(d => \n            domain.endsWith(d) || domain === d\n        );\n        \n        console.log('Domain dismissed status:', isDismissed);\n        return isDismissed;\n    } catch (error) {\n        console.error('Error checking dismissed domains:', error);\n        return false;\n    }\n}\n\n// Update the extension icon based on domain dismissal status\nasync function updateExtensionIcon(domain, isDismissed) {\n    try {\n        // First get the current tab ID\n        const tabs = await chrome.tabs.query({ active: true, currentWindow: true });\n        const tabId = tabs && tabs[0] && tabs[0].id;\n        \n        if (!tabId) {\n            console.warn('Could not get current tab ID for icon update');\n            return;\n        }\n        \n        console.log(`Updating icon for tab ${tabId}, isDismissed: ${isDismissed}`);\n        \n        // Send message to update the icon\n        await chrome.runtime.sendMessage({\n            action: 'updateIcon',\n            tabId: tabId,\n            isDismissed: isDismissed\n        });\n    } catch (error) {\n        console.error('Error updating extension icon:', error);\n    }\n}\n\nasync function dismissDomain(domain) {\n    try {\n        console.log('Dismissing domain:', domain);\n        const result = await chrome.storage.local.get(STORAGE_KEYS.DISMISSED_DOMAINS);\n        const dismissedDomains = result[STORAGE_KEYS.DISMISSED_DOMAINS] || [];\n        \n        // Check if this exact domain or a parent domain is already in the list\n        const existingDomain = dismissedDomains.find(d => \n            domain === d || domain.endsWith('.' + d)\n        );\n        \n        if (existingDomain) {\n            console.log('Domain or parent domain already in dismissed list:', existingDomain);\n        } else {\n            dismissedDomains.push(domain);\n            console.log('Saving dismissed domains:', dismissedDomains);\n            await chrome.storage.local.set({ [STORAGE_KEYS.DISMISSED_DOMAINS]: dismissedDomains });\n        }\n        \n        // Notify the background script to update the icon\n        try {\n            // First try to get the current tab ID\n            let tabId;\n            \n            // Method 1: Try using chrome.tabs if available\n            if (chrome.tabs && chrome.tabs.query) {\n                try {\n                    const tabs = await chrome.tabs.query({ active: true, currentWindow: true });\n                    if (tabs && tabs[0]?.id) {\n                        tabId = tabs[0].id;\n                    }\n                } catch (e) {\n                    console.warn('Could not get tab ID using chrome.tabs:', e);\n                }\n            }\n            \n            // Method 2: If we couldn't get tabId, use a message to the background script\n            if (!tabId) {\n                console.log('No tab ID available, using background script to update icon');\n                await chrome.runtime.sendMessage({\n                    action: 'dismissDomain',\n                    domain: domain\n                });\n            } else {\n                console.log('Updating icon for tab:', tabId);\n                // Update the icon directly if we have the tab ID\n                await chrome.runtime.sendMessage({\n                    action: 'updateIcon',\n                    tabId: tabId,\n                    isDismissed: true\n                });\n                \n                // Update badge if available\n                if (chrome.action && chrome.action.setBadgeText) {\n                    try {\n                        await chrome.action.setBadgeText({\n                            tabId: tabId,\n                            text: 'X'\n                        });\n                        await chrome.action.setBadgeBackgroundColor({\n                            tabId: tabId,\n                            color: '#dc3545' // Red color\n                        });\n                    } catch (e) {\n                        console.warn('Could not update badge:', e);\n                    }\n                }\n            }\n        } catch (e) {\n            console.error('Error updating icon:', e);\n        }\n        \n        return true;\n    } catch (error) {\n        console.error('Error saving dismissed domain:', error);\n        return false;\n    }\n}\n\n/**\n * Checks if auto-redirect is enabled in the extension settings\n * @returns {Promise<boolean>} True if auto-redirect is enabled\n */\nasync function shouldAutoRedirect() {\n    try {\n        const result = await chrome.storage.local.get(STORAGE_KEYS.AUTO_REDIRECT);\n        // Return the stored value or default to false if not set\n        return result[STORAGE_KEYS.AUTO_REDIRECT] === true;\n    } catch (error) {\n        console.error('Error checking auto-redirect setting:', error);\n        // Default to false on error to avoid unwanted redirects\n        return false;\n    }\n}\n\nfunction adjustPageMargin(bannerHeight) {\n    // Only adjust if there's no existing top margin/padding that might conflict\n    const currentMargin = parseInt(getComputedStyle(document.body).marginTop) || 0;\n    if (currentMargin < bannerHeight) {\n        document.body.style.marginTop = bannerHeight + 'px';\n    }\n}\n\nfunction restorePageMargin() {\n    // Check if we need to restore the original margin\n    const banner = document.getElementById(BANNER_ID);\n    if (!banner) {\n        document.body.style.marginTop = '';\n    }\n}\n\n/**\n * Creates and displays a notification banner for EZProxy access\n * @param {string} message - The message to display in the banner\n * @param {string} ezproxyUrl - The URL to redirect to for EZProxy access\n * @param {string} domain - The domain that was matched\n * @returns {Promise<void>}\n */\nasync function createBanner(message, ezproxyUrl, domain) {\n    // Get the current configuration\n    const config = await getConfig();\n    const bannerConfig = config.banner || {};\n    \n    // Remove existing banner if any\n    const existingBanner = document.getElementById(BANNER_ID);\n    if (existingBanner) {\n        existingBanner.remove();\n    }\n\n    // Create banner elements\n    const banner = document.createElement('div');\n    banner.id = BANNER_ID;\n    banner.setAttribute('role', 'banner');\n    banner.setAttribute('aria-label', 'EZProxy access notification');\n    \n    // Base styles\n    const baseStyles = `\n        position: fixed;\n        top: 0;\n        left: 0;\n        right: 0;\n        background-color: ${bannerConfig.backgroundColor || '#f8f9fa'};\n        color: ${bannerConfig.textColor || '#495057'};\n        border-bottom: 1px solid ${bannerConfig.borderColor || '#dee2e6'};\n        padding: ${bannerConfig.padding || '12px 20px'};\n        display: flex;\n        justify-content: space-between;\n        align-items: center;\n        z-index: ${bannerConfig.zIndex || '2147483647'};\n        font-family: ${bannerConfig.fontFamily || '-apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, sans-serif'};\n        box-shadow: ${bannerConfig.boxShadow || '0 2px 4px rgba(0,0,0,0.1)'};\n        font-size: ${bannerConfig.fontSize || '14px'};\n        line-height: ${bannerConfig.lineHeight || '1.5'};\n    `;\n    \n    // Add animation styles if motion is not reduced\n    const animationStyles = prefersReducedMotion ? '' : `\n        transform: translateY(-100%);\n        transition: transform ${bannerConfig.animationDuration || '0.3s'} ease-out;\n    `;\n    \n    // Mobile responsive styles\n    const mobileBreakpoint = bannerConfig.mobileBreakpoint || '768px';\n    const responsiveStyles = `\n        @media (max-width: ${mobileBreakpoint}) {\n            flex-direction: column;\n            gap: 10px;\n            padding: 15px !important;\n            text-align: center;\n        }\n    `;\n    \n    banner.style.cssText = baseStyles + animationStyles;\n    \n    // Add responsive styles\n    if (!document.getElementById('ezproxy-banner-styles')) {\n        const style = document.createElement('style');\n        style.id = 'ezproxy-banner-styles';\n        style.textContent = `\n            #${BANNER_ID} ${responsiveStyles}\n            #${BANNER_ID} .banner-buttons {\n                display: flex;\n                gap: 10px;\n                align-items: center;\n            }\n            @media (max-width: 768px) {\n                #${BANNER_ID} .banner-buttons {\n                    justify-content: center;\n                    width: 100%;\n                }\n                #${BANNER_ID} .banner-message {\n                    margin-bottom: 5px;\n                }\n            }\n        `;\n        document.head.appendChild(style);\n    }\n\n    // Create message div\n    const messageDiv = document.createElement('div');\n    messageDiv.className = 'banner-message';\n    messageDiv.textContent = message;\n    messageDiv.style.cssText = `\n        color: ${bannerConfig.textColor || '#495057'};\n        flex: 1;\n        margin-right: 15px;\n    `;\n\n    const buttonsDiv = document.createElement('div');\n    buttonsDiv.className = 'banner-buttons';\n\n    // Get button configurations with fallbacks\n    const buttonConfig = bannerConfig.button || {};\n    const dismissButtonConfig = bannerConfig.dismissButton || {};\n    const closeButtonConfig = bannerConfig.closeButton || {};\n\n    // Main redirect button\n    const redirectButton = document.createElement('button');\n    \n    // Check if this is an exception domain and use appropriate button text\n    const isExceptionDomain = sessionStorage.getItem('ezproxy-exception-domain') === 'true';\n    if (isExceptionDomain) {\n        // Use the stored button text or fallback to default\n        const exceptionButtonText = sessionStorage.getItem('ezproxy-exception-button-text') || 'How to Access';\n        const exceptionButtonAriaLabel = sessionStorage.getItem('ezproxy-exception-button-aria') || \n            'Learn how to access this resource through your library';\n        \n        redirectButton.textContent = exceptionButtonText;\n        redirectButton.setAttribute('aria-label', exceptionButtonAriaLabel);\n        \n        // Clear the session storage items after using them\n        sessionStorage.removeItem('ezproxy-exception-domain');\n        sessionStorage.removeItem('ezproxy-exception-button-text');\n        sessionStorage.removeItem('ezproxy-exception-button-aria');\n    } else {\n        redirectButton.textContent = buttonConfig.text || 'Access via EZProxy';\n        redirectButton.setAttribute('aria-label', 'Access this resource via EZProxy');\n    }\n    \n    // Apply button styles\n    redirectButton.style.cssText = `\n        background-color: ${buttonConfig.backgroundColor || '#0d6efd'};\n        color: ${buttonConfig.textColor || '#ffffff'};\n        border: none;\n        padding: ${buttonConfig.padding || '8px 16px'};\n        border-radius: ${buttonConfig.borderRadius || '4px'};\n        cursor: pointer;\n        font-size: ${bannerConfig.fontSize || '14px'};\n        font-weight: 500;\n        transition: all 0.2s ease;\n    `;\n    \n    // Add hover and focus styles\n    redirectButton.addEventListener('mouseenter', () => {\n        redirectButton.style.backgroundColor = buttonConfig.hoverColor || '#0b5ed7';\n        redirectButton.style.transform = 'translateY(-1px)';\n    });\n    \n    redirectButton.addEventListener('mouseleave', () => {\n        redirectButton.style.backgroundColor = buttonConfig.backgroundColor || '#0d6efd';\n        redirectButton.style.transform = '';\n    });\n    \n    redirectButton.addEventListener('focus', () => {\n        redirectButton.style.outline = `2px solid ${buttonConfig.hoverColor || '#0b5ed7'}`;\n        redirectButton.style.outlineOffset = '2px';\n    });\n    \n    redirectButton.addEventListener('blur', () => {\n        redirectButton.style.outline = '';\n        redirectButton.style.outlineOffset = '';\n    });\n    \n    redirectButton.addEventListener('click', () => {\n        window.location.href = ezproxyUrl;\n    });\n\n    // Dismiss button (for domain)\n    const dismissButton = document.createElement('button');\n    dismissButton.textContent = dismissButtonConfig.text || 'Dismiss';\n    dismissButton.setAttribute('aria-label', 'Dismiss this notification');\n    \n    // Apply dismiss button styles\n    dismissButton.style.cssText = `\n        background-color: ${dismissButtonConfig.backgroundColor || 'transparent'};\n        color: ${dismissButtonConfig.textColor || '#6c757d'};\n        border: 1px solid ${bannerConfig.borderColor || '#dee2e6'};\n        padding: ${dismissButtonConfig.padding || '6px 12px'};\n        border-radius: ${dismissButtonConfig.borderRadius || '4px'};\n        margin-right: 10px;\n        cursor: pointer;\n        font-size: ${bannerConfig.fontSize || '14px'};\n        transition: all 0.2s ease;\n    `;\n    \n    // Add hover and focus styles for dismiss button\n    dismissButton.addEventListener('mouseenter', () => {\n        dismissButton.style.backgroundColor = dismissButtonConfig.hoverColor || '#e9ecef';\n        dismissButton.style.borderColor = bannerConfig.borderColor || '#ced4da';\n        dismissButton.style.transform = 'translateY(-1px)';\n    });\n    \n    dismissButton.addEventListener('mouseleave', () => {\n        dismissButton.style.backgroundColor = dismissButtonConfig.backgroundColor || 'transparent';\n        dismissButton.style.borderColor = bannerConfig.borderColor || '#dee2e6';\n        dismissButton.style.transform = '';\n    });\n    \n    dismissButton.addEventListener('focus', () => {\n        dismissButton.style.outline = `2px solid ${dismissButtonConfig.hoverColor || '#6c757d'}`;\n        dismissButton.style.outlineOffset = '2px';\n    });\n    \n    dismissButton.addEventListener('blur', () => {\n        dismissButton.style.outline = '';\n        dismissButton.style.outlineOffset = '';\n    });\n    \n    dismissButton.addEventListener('click', async () => {\n        await dismissDomain(domain);\n        removeBanner();\n    });\n    \n    // Close button (for current session only)\n    const closeButton = document.createElement('button');\n    closeButton.innerHTML = closeButtonConfig.text || '&times;';\n    closeButton.setAttribute('aria-label', 'Close this notification');\n    \n    // Apply close button styles\n    closeButton.style.cssText = `\n        background: transparent;\n        border: none;\n        font-size: 20px;\n        font-weight: bold;\n        color: ${closeButtonConfig.color || '#6c757d'};\n        cursor: pointer;\n        padding: 0 0 0 10px;\n        line-height: 1;\n        width: 24px;\n        height: 24px;\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        border-radius: 50%;\n        transition: all 0.2s ease;\n    `;\n    \n    // Add hover and focus styles for close button\n    closeButton.addEventListener('mouseenter', () => {\n        closeButton.style.backgroundColor = closeButtonConfig.hoverColor || '#e9ecef';\n        closeButton.style.color = closeButtonConfig.hoverColor || '#212529';\n        closeButton.style.transform = 'scale(1.1)';\n    });\n    \n    closeButton.addEventListener('mouseleave', () => {\n        closeButton.style.backgroundColor = 'transparent';\n        closeButton.style.color = closeButtonConfig.color || '#6c757d';\n        closeButton.style.transform = '';\n    });\n    \n    closeButton.addEventListener('focus', () => {\n        closeButton.style.outline = `2px solid ${closeButtonConfig.hoverColor || '#6c757d'}`;\n        closeButton.style.outlineOffset = '2px';\n    });\n    \n    closeButton.addEventListener('blur', () => {\n        closeButton.style.outline = '';\n        closeButton.style.outlineOffset = '';\n    });\n    \n    closeButton.addEventListener('click', removeBanner);\n\n    // Keyboard navigation\n    banner.addEventListener('keydown', (e) => {\n        if (e.key === 'Escape') {\n            removeBanner();\n        }\n    });\n\n    // Assemble banner\n    buttonsDiv.appendChild(redirectButton);\n    buttonsDiv.appendChild(dismissButton);\n    buttonsDiv.appendChild(closeButton);\n    banner.appendChild(messageDiv);\n    banner.appendChild(buttonsDiv);\n\n    // Add banner to page\n    document.body.insertBefore(banner, document.body.firstChild);\n\n    // Animate in if motion is not reduced\n    if (!prefersReducedMotion) {\n        // Force reflow to ensure initial transform is applied\n        banner.offsetHeight;\n        banner.style.transform = 'translateY(0)';\n    }\n\n    // Adjust page margin to prevent content overlap\n    const bannerHeight = banner.offsetHeight;\n    adjustPageMargin(bannerHeight);\n\n    // Set focus to the main button for accessibility\n    setTimeout(() => {\n        redirectButton.focus();\n    }, prefersReducedMotion ? 0 : 100);\n}\n\n// Remove banner notification\nasync function removeBanner() {\n    const banner = document.getElementById(BANNER_ID);\n    if (!banner) return;\n    \n    const bannerConfig = (await getConfig()).banner || {};\n    const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;\n    \n    if (prefersReducedMotion) {\n        banner.remove();\n        restorePageMargin();\n    } else {\n        banner.style.transition = `transform ${bannerConfig.animationDuration || '0.3s'} ease-out`;\n        banner.style.transform = 'translateY(-100%)';\n        \n        // Use a promise to handle the animation end\n        await new Promise(resolve => {\n            banner.addEventListener('transitionend', () => resolve(), { once: true });\n            // Fallback in case transitionend doesn't fire\n            setTimeout(resolve, bannerConfig.animationDuration ? \n                (parseFloat(bannerConfig.animationDuration) * 1000) : 300);\n        });\n        \n        banner.remove();\n        restorePageMargin();\n    }\n    \n    // Remove any keyboard focus from banner elements\n    if (document.activeElement && document.activeElement.closest(`#${BANNER_ID}`)) {\n        document.activeElement.blur();\n    }\n}\n\n/**\n * Check if current URL is an EZProxy URL for an exception domain\n * @param {Object} config - The configuration object\n * @returns {Object|null} - Object with original domain if match found, null otherwise\n */\nfunction checkEZProxyExceptionURL(config) {\n    const currentUrl = window.location.href;\n    const currentHostname = window.location.hostname;\n    \n    // Check if we're on an EZProxy domain\n    if (!config.ezproxyBaseUrl || !currentHostname.includes(config.ezproxyBaseUrl)) {\n        return null;\n    }\n    \n    // Parse the EZProxy URL format to extract the original domain\n    // Format is typically: https://www-example-com.ezproxy.library.wwu.edu/path\n    const ezproxyPattern = new RegExp(`^([^.]+)\\\\.${config.ezproxyBaseUrl.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}`);\n    const match = currentHostname.match(ezproxyPattern);\n    \n    if (!match) {\n        return null;\n    }\n    \n    // Convert the transformed domain back to original format\n    // www-example-com -> www.example.com\n    const transformedDomain = match[1];\n    const originalDomain = transformedDomain.replace(/-/g, '.');\n    \n    // Check if this original domain is in our exception list\n    if (config.urlExceptions && Array.isArray(config.urlExceptions)) {\n        const matchedExceptionDomain = config.urlExceptions.find(exception => \n            originalDomain.includes(exception) || originalDomain === exception\n        );\n        \n        if (matchedExceptionDomain) {\n            return {\n                originalDomain: originalDomain,\n                exceptionDomain: matchedExceptionDomain\n            };\n        }\n    }\n    \n    return null;\n}\n\n/**\n * Utility to extract the base domain (e.g., ft.com) from a hostname (e.g., www.ft.com)\n * @param {string} hostname\n * @returns {string} base domain\n */\nfunction getBaseDomain(hostname) {\n    // Remove port if present\n    hostname = hostname.split(':')[0];\n    // Split by dot\n    const parts = hostname.split('.');\n    if (parts.length <= 2) {\n        return hostname;\n    }\n    // Return last two parts (handles most cases like www.ft.com -> ft.com)\n    return parts.slice(-2).join('.');\n}\n\n/**\n * Create secondary help banner for EZProxy exception domains\n * @param {string} originalDomain - The original domain name\n * @param {string} helpUrl - The help URL with search parameter\n * @param {string} buttonText - Text for the help button\n */\nasync function createSecondaryBanner(originalDomain, helpUrl, buttonText) {\n    const config = await getConfig();\n    const bannerConfig = config.banner || {};\n    \n    // Remove existing secondary banner if any\n    const existingBanner = document.getElementById(SECONDARY_BANNER_ID);\n    if (existingBanner) {\n        existingBanner.remove();\n    }\n\n    // Create secondary banner elements\n    const banner = document.createElement('div');\n    banner.id = SECONDARY_BANNER_ID;\n    banner.setAttribute('role', 'banner');\n    banner.setAttribute('aria-label', 'Library help information');\n    \n    // Base styles - similar to main banner but with different colors\n    const baseStyles = `\n        position: fixed;\n        top: 0;\n        left: 0;\n        right: 0;\n        background-color: #e8f4f8;\n        color: #155e75;\n        border-bottom: 1px solid #0891b2;\n        padding: ${bannerConfig.padding || '12px 20px'};\n        display: flex;\n        justify-content: space-between;\n        align-items: center;\n        z-index: ${bannerConfig.zIndex || '2147483647'};\n        font-family: ${bannerConfig.fontFamily || '-apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, sans-serif'};\n        box-shadow: ${bannerConfig.boxShadow || '0 2px 4px rgba(0,0,0,0.1)'};\n        font-size: ${bannerConfig.fontSize || '14px'};\n        line-height: ${bannerConfig.lineHeight || '1.5'};\n    `;\n    \n    // Add animation styles if motion is not reduced\n    const animationStyles = prefersReducedMotion ? '' : `\n        transform: translateY(-100%);\n        transition: transform ${bannerConfig.animationDuration || '0.3s'} ease-out;\n    `;\n    \n    banner.style.cssText = baseStyles + animationStyles;\n\n    // Create message div\n    const messageDiv = document.createElement('div');\n    messageDiv.className = 'banner-message';\n    messageDiv.textContent = `This site may require additional steps.  Please see the 'Info for this site' button.`;\n    messageDiv.style.cssText = `\n        color: #155e75;\n        flex: 1;\n        margin-right: 15px;\n    `;\n\n    const buttonsDiv = document.createElement('div');\n    buttonsDiv.className = 'banner-buttons';\n    buttonsDiv.style.cssText = `\n        display: flex;\n        gap: 10px;\n        align-items: center;\n    `;\n\n    // Help button\n    const helpButton = document.createElement('button');\n    helpButton.textContent = buttonText;\n    helpButton.setAttribute('aria-label', `Get help information for ${originalDomain}`);\n    \n    // Apply button styles\n    helpButton.style.cssText = `\n        background-color: #0891b2;\n        color: #ffffff;\n        border: none;\n        padding: 8px 16px;\n        border-radius: 4px;\n        cursor: pointer;\n        font-size: ${bannerConfig.fontSize || '14px'};\n        font-weight: 500;\n        transition: all 0.2s ease;\n    `;\n    \n    // Add hover and focus styles\n    helpButton.addEventListener('mouseenter', () => {\n        helpButton.style.backgroundColor = '#0e7490';\n        helpButton.style.transform = 'translateY(-1px)';\n    });\n    \n    helpButton.addEventListener('mouseleave', () => {\n        helpButton.style.backgroundColor = '#0891b2';\n        helpButton.style.transform = '';\n    });\n    \n    helpButton.addEventListener('focus', () => {\n        helpButton.style.outline = '2px solid #0e7490';\n        helpButton.style.outlineOffset = '2px';\n    });\n    \n    helpButton.addEventListener('blur', () => {\n        helpButton.style.outline = '';\n        helpButton.style.outlineOffset = '';\n    });\n    \n    helpButton.addEventListener('click', () => {\n        window.open(helpUrl, '_blank');\n    });\n\n    // Close button\n    const closeButton = document.createElement('button');\n    closeButton.innerHTML = '&times;';\n    closeButton.setAttribute('aria-label', 'Close this notification');\n    \n    closeButton.style.cssText = `\n        background: transparent;\n        border: none;\n        font-size: 20px;\n        font-weight: bold;\n        color: #155e75;\n        cursor: pointer;\n        padding: 0 0 0 10px;\n        line-height: 1;\n        width: 24px;\n        height: 24px;\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        border-radius: 50%;\n        transition: all 0.2s ease;\n    `;\n    \n    closeButton.addEventListener('mouseenter', () => {\n        closeButton.style.backgroundColor = '#cffafe';\n        closeButton.style.transform = 'scale(1.1)';\n    });\n    \n    closeButton.addEventListener('mouseleave', () => {\n        closeButton.style.backgroundColor = 'transparent';\n        closeButton.style.transform = '';\n    });\n    \n    closeButton.addEventListener('focus', () => {\n        closeButton.style.outline = '2px solid #0e7490';\n        closeButton.style.outlineOffset = '2px';\n    });\n    \n    closeButton.addEventListener('blur', () => {\n        closeButton.style.outline = '';\n        closeButton.style.outlineOffset = '';\n    });\n    \n    closeButton.addEventListener('click', removeSecondaryBanner);\n\n    // Keyboard navigation\n    banner.addEventListener('keydown', (e) => {\n        if (e.key === 'Escape') {\n            removeSecondaryBanner();\n        }\n    });\n\n    // Assemble banner\n    buttonsDiv.appendChild(helpButton);\n    buttonsDiv.appendChild(closeButton);\n    banner.appendChild(messageDiv);\n    banner.appendChild(buttonsDiv);\n\n    // Add banner to page\n    document.body.insertBefore(banner, document.body.firstChild);\n\n    // Animate in if motion is not reduced\n    if (!prefersReducedMotion) {\n        // Force reflow to ensure initial transform is applied\n        banner.offsetHeight;\n        banner.style.transform = 'translateY(0)';\n    }\n\n    // Adjust page margin to prevent content overlap\n    const bannerHeight = banner.offsetHeight;\n    adjustPageMargin(bannerHeight);\n\n    // Set focus to the help button for accessibility\n    setTimeout(() => {\n        helpButton.focus();\n    }, prefersReducedMotion ? 0 : 100);\n}\n\n/**\n * Remove secondary banner notification\n */\nasync function removeSecondaryBanner() {\n    const banner = document.getElementById(SECONDARY_BANNER_ID);\n    if (!banner) return;\n    \n    const bannerConfig = (await getConfig()).banner || {};\n    const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;\n    \n    if (prefersReducedMotion) {\n        banner.remove();\n        restorePageMargin();\n    } else {\n        banner.style.transition = `transform ${bannerConfig.animationDuration || '0.3s'} ease-out`;\n        banner.style.transform = 'translateY(-100%)';\n        \n        // Use a promise to handle the animation end\n        await new Promise(resolve => {\n            banner.addEventListener('transitionend', () => resolve(), { once: true });\n            // Fallback in case transitionend doesn't fire\n            setTimeout(resolve, bannerConfig.animationDuration ? \n                (parseFloat(bannerConfig.animationDuration) * 1000) : 300);\n        });\n        \n        banner.remove();\n        restorePageMargin();\n    }\n    \n    // Remove any keyboard focus from banner elements\n    if (document.activeElement && document.activeElement.closest(`#${SECONDARY_BANNER_ID}`)) {\n        document.activeElement.blur();\n    }\n}\n\n/**\n * Initialize the content script\n */\nasync function init() {\n    if (isInitialized) return;\n    \n    // Check if we're on an EZProxy URL for an exception domain\n    try {\n        const config = await getConfig();\n        const ezproxyMatch = checkEZProxyExceptionURL(config);\n        \n        if (ezproxyMatch) {\n            console.log('[init] Detected EZProxy exception URL for domain:', ezproxyMatch.originalDomain);\n            // Create the help URL with the BASE domain as search parameter\n            const libraryHelpUrl = config.libraryHelpUrl || 'https://library.example.edu/ask';\n            const baseDomain = getBaseDomain(ezproxyMatch.originalDomain);\n            const helpUrlWithSearch = `${libraryHelpUrl}${libraryHelpUrl.includes('?') ? '&' : '?'}q=${baseDomain}`;\n            // Get the button text from config\n            const buttonText = config.secondaryHelpButtonText || 'Info for this site';\n            // Show the secondary banner\n            await createSecondaryBanner(ezproxyMatch.originalDomain, helpUrlWithSearch, buttonText);\n        }\n    } catch (error) {\n        console.error('[init] Error checking for EZProxy exception URL:', error);\n    }\n    \n    // Listen for storage changes to update the banner when domains are undismissed\n    chrome.storage.onChanged.addListener((changes, areaName) => {\n        if (areaName === 'local' && changes.dismissedDomains) {\n            // Remove existing banner if any\n            const banner = document.getElementById(BANNER_ID);\n            if (banner) {\n                banner.remove();\n                restorePageMargin();\n            }\n            \n            // Re-check if we should show the banner\n            const currentUrl = window.location.href;\n            checkAndShowBanner(currentUrl);\n        }\n    });\n    \n    isInitialized = true;\n}\n\n/**\n * Check if we should show the banner for the current URL and show it if needed\n * @param {string} url - The URL to check\n */\nasync function checkAndShowBanner(url) {\n    console.log('[checkAndShowBanner] Starting check for URL:', url);\n    \n    if (!url || typeof url !== 'string') {\n        console.error('[checkAndShowBanner] Invalid URL provided:', url);\n        return;\n    }\n    \n    try {\n        // Step 1: Load configuration\n        console.log('[checkAndShowBanner] Step 1: Loading configuration...');\n        const config = await getConfig().catch(err => {\n            console.error('[checkAndShowBanner] Failed to load config:', err);\n            throw new Error('Failed to load extension configuration');\n        });\n        \n        if (!config) {\n            console.error('[checkAndShowBanner] No configuration loaded');\n            return;\n        }\n        \n        console.log('[checkAndShowBanner] Config loaded:', {\n            institutionName: config.institutionName,\n            ezproxyBaseUrl: config.ezproxyBaseUrl ? '***' : 'Not set',\n            hasAccessIndicators: Array.isArray(config.accessIndicators) ? config.accessIndicators.length : 0\n        });\n        \n        // Step 2: Load domain list\n        console.log('[checkAndShowBanner] Step 2: Loading domain list...');\n        const domainList = await getDomainList().catch(err => {\n            console.error('[checkAndShowBanner] Failed to load domain list:', err);\n            throw new Error('Failed to load domain list');\n        });\n        \n        console.log(`[checkAndShowBanner] Domain list loaded with ${domainList.length} entries`);\n        \n        // Step 3: Parse and validate URL\n        console.log('[checkAndShowBanner] Step 3: Parsing URL...');\n        let domain;\n        try {\n            const urlObj = new URL(url);\n            domain = urlObj.hostname;\n            console.log('[checkAndShowBanner] Extracted domain:', domain);\n            \n            // Check for IP address (skip if it's an IP)\n            if (/^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$/.test(domain)) {\n                console.log('[checkAndShowBanner] IP address detected, skipping banner check');\n                return;\n            }\n        } catch (e) {\n            console.error('[checkAndShowBanner] Invalid URL:', url, 'Error:', e);\n            return;\n        }\n        \n        // Step 4: Check domain against domain list\n        console.log('[checkAndShowBanner] Step 4: Checking domain against domain list...');\n        const matchedDomain = domainList.find(d => {\n            const exactMatch = domain === d;\n            const subdomainMatch = domain.endsWith('.' + d);\n            console.log(`[checkAndShowBanner] Checking ${d}: exact=${exactMatch}, subdomain=${subdomainMatch}`);\n            return exactMatch || subdomainMatch;\n        });\n        \n        if (!matchedDomain) {\n            console.log('[checkAndShowBanner] Domain not in list, updating icon to normal state');\n            // Update icon to normal state for non-library domains\n            try {\n                const [tab] = await chrome.runtime.sendMessage({ action: 'getTab' });\n                if (tab?.id) {\n                    await chrome.runtime.sendMessage({\n                        action: 'updateIcon',\n                        tabId: tab.id,\n                        isDismissed: false\n                    });\n                }\n            } catch (e) {\n                console.error('[checkAndShowBanner] Error updating icon for non-library domain:', e);\n            }\n            return;\n        }\n        \n        console.log('[checkAndShowBanner] Matched domain in list:', matchedDomain);\n        \n        // Step 5: Check if domain is dismissed\n        console.log('[checkAndShowBanner] Step 5: Checking if domain is dismissed...');\n        const isDismissed = await isDomainDismissed(matchedDomain).catch(err => {\n            console.error('[checkAndShowBanner] Error checking if domain is dismissed:', err);\n            return false; // Default to not dismissed on error\n        });\n        \n        if (isDismissed) {\n            console.log('[checkAndShowBanner] Domain is dismissed, updating icon to dismissed state');\n            try {\n                const [tab] = await chrome.runtime.sendMessage({ action: 'getTab' });\n                if (tab?.id) {\n                    await chrome.runtime.sendMessage({\n                        action: 'updateIcon',\n                        tabId: tab.id,\n                        isDismissed: true\n                    });\n                }\n            } catch (e) {\n                console.error('[checkAndShowBanner] Error updating icon for dismissed domain:', e);\n            }\n            return;\n        }\n        \n        // Step 6: Check for institutional access\n        console.log('[checkAndShowBanner] Step 6: Checking for institutional access...');\n        try {\n            const hasAccess = hasInstitutionalAccess(config);\n            \n            if (hasAccess) {\n                console.log('[checkAndShowBanner] User has institutional access, skipping EZProxy notification');\n                return;\n            }\n            console.log('[checkAndShowBanner] No institutional access detected, proceeding with banner check');\n        } catch (e) {\n            console.error('[checkAndShowBanner] Error checking institutional access:', e);\n            // Continue with banner display if we can't determine access\n        }\n        \n        // Step 7: Double-check if domain was dismissed (race condition protection)\n        console.log('[checkAndShowBanner] Step 7: Verifying domain is still not dismissed...');\n        const isStillDismissed = await isDomainDismissed(matchedDomain).catch(() => false);\n        if (isStillDismissed) {\n            console.log('[checkAndShowBanner] Domain was dismissed during processing, aborting');\n            return;\n        }\n        \n        // Step 8: Prepare EZProxy URL\n        console.log('[checkAndShowBanner] Step 8: Preparing EZProxy URL...');\n        if (!config.ezproxyBaseUrl) {\n            console.error('[checkAndShowBanner] No EZProxy base URL configured');\n            return;\n        }\n        \n        let ezproxyBase = config.ezproxyBaseUrl.trim();\n        if (!ezproxyBase.endsWith('/')) {\n            ezproxyBase = `${ezproxyBase}/`;\n        }\n        \n        // Clean the target URL\n        let targetUrl = url;\n        const httpMatch = targetUrl.match(/^https?:\\/\\/(.*)/i);\n        if (httpMatch) {\n            targetUrl = httpMatch[1];\n        }\n        \n        // Check if the domain is in the exceptions list\n        const matchedExceptionDomain = Array.isArray(config.urlExceptions) ? \n            config.urlExceptions.find(exception => matchedDomain.includes(exception)) : null;\n        const isException = !!matchedExceptionDomain;\n        \n        let ezproxyUrl;\n        let bannerMessage;\n        let buttonText;\n        let buttonAriaLabel;\n        \n        if (isException) {\n            // For exceptions, create a URL to the library help page with the domain as a search parameter\n            const libraryHelpUrl = config.libraryHelpUrl || 'https://library.example.edu/ask';\n            const baseDomain = getBaseDomain(matchedDomain);\n            const helpUrlWithSearch = `${libraryHelpUrl}${libraryHelpUrl.includes('?') ? '&' : '?'}q=${baseDomain}`;\n            ezproxyUrl = helpUrlWithSearch;\n            \n            // Create a more specific message for the exception domain\n            bannerMessage = `${matchedExceptionDomain} requires special access and cannot be accessed via standard EZProxy. Please visit your library's help page for assistance.`;\n            buttonText = 'How to Access';\n            buttonAriaLabel = 'Learn how to access this resource through your library';\n            \n            console.log(`[checkAndShowBanner] Domain ${matchedDomain} is an exception (${matchedExceptionDomain}). Using help URL:`, ezproxyUrl);\n            \n            // Store the exception information to modify the banner later\n            sessionStorage.setItem('ezproxy-exception-domain', 'true');\n            sessionStorage.setItem('ezproxy-exception-button-text', buttonText);\n            sessionStorage.setItem('ezproxy-exception-button-aria', buttonAriaLabel);\n        } else {\n            // Standard EZProxy URL creation\n            ezproxyUrl = `${ezproxyBase}${targetUrl}`;\n            bannerMessage = `This resource is available through ${config.institutionName || 'your library'}. Access the full content via EZProxy.`;\n            console.log('[checkAndShowBanner] Created standard EZProxy URL:', ezproxyUrl);\n        }\n        \n        // Step 9: Create and show the banner\n        console.log('[checkAndShowBanner] Step 9: Creating banner...');\n        try {\n            await createBanner(\n                bannerMessage,\n                ezproxyUrl,\n                matchedDomain\n            );\n            console.log('[checkAndShowBanner] Banner creation completed successfully');\n        } catch (e) {\n            console.error('[checkAndShowBanner] Error creating banner:', e);\n            throw e; // Re-throw to be caught by the outer try-catch\n        }\n    } catch (error) {\n        console.error('[checkAndShowBanner] Unhandled error:', error);\n        // Try to show a generic error banner if possible\n        try {\n            const errorBanner = document.createElement('div');\n            errorBanner.style.position = 'fixed';\n            errorBanner.style.top = '10px';\n            errorBanner.style.right = '10px';\n            errorBanner.style.padding = '10px';\n            errorBanner.style.backgroundColor = '#ffebee';\n            errorBanner.style.border = '1px solid #ef9a9a';\n            errorBanner.style.borderRadius = '4px';\n            errorBanner.style.zIndex = '100000';\n            errorBanner.style.maxWidth = '300px';\n            errorBanner.style.fontFamily = 'Arial, sans-serif';\n            errorBanner.style.fontSize = '14px';\n            errorBanner.innerHTML = `\n                <div style=\"font-weight: bold; margin-bottom: 5px;\">EZProxy Extension Error</div>\n                <div>${error.message || 'An unknown error occurred'}</div>\n                <div style=\"margin-top: 5px; font-size: 12px; color: #666;\">\n                    Check console for details\n                </div>\n            `;\n            document.body.appendChild(errorBanner);\n            \n            // Auto-remove after 10 seconds\n            setTimeout(() => {\n                if (document.body.contains(errorBanner)) {\n                    errorBanner.remove();\n                }\n            }, 10000);\n        } catch (e) {\n            console.error('Could not display error banner:', e);\n        }\n    }\n}\n\n// Initialize when DOM is fully loaded\nif (document.readyState === 'loading') {\n    document.addEventListener('DOMContentLoaded', init);\n} else {\n    init();\n}\n\n// Enhanced message listener with auto-redirect support\nchrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n    if (message.type === 'DOMAIN_MATCH') {\n        console.log('[onMessage] Received DOMAIN_MATCH message for:', message.domain);\n        \n        // Process the message asynchronously but respond immediately\n        // to prevent connection issues\n        sendResponse({ received: true });\n        \n        // Use a promise chain to handle all the checks in sequence\n        getConfig()\n            .then(config => {\n                // Store the config for later use\n                const configData = config;\n                \n                // First check if the domain was dismissed\n                return isDomainDismissed(message.domain)\n                    .then(dismissed => {\n                        if (dismissed) {\n                            console.log('[onMessage] Domain was previously dismissed, skipping notification');\n                            throw new Error('DOMAIN_DISMISSED');\n                        }\n                        return configData;\n                    });\n            })\n            .then(config => {\n                // Then check for institutional access\n                return hasInstitutionalAccess(config)\n                    .then(hasAccess => {\n                        if (hasAccess) {\n                            console.log('[onMessage] User has institutional access, skipping EZProxy notification');\n                            throw new Error('HAS_INSTITUTIONAL_ACCESS');\n                        }\n                        return config;\n                    })\n                    .catch(err => {\n                        if (err.message === 'HAS_INSTITUTIONAL_ACCESS') {\n                            throw err;\n                        }\n                        // If there's an error checking access, continue with banner\n                        console.warn('[onMessage] Error checking institutional access, proceeding with banner:', err);\n                        return config;\n                    });\n            })\n            .then(config => {\n                // Then check for auto-redirect\n                return shouldAutoRedirect()\n                    .then(shouldRedirect => {\n                        if (shouldRedirect) {\n                            console.log('[onMessage] Auto-redirect enabled, redirecting to EZProxy');\n                            window.location.href = message.ezproxyUrl;\n                            throw new Error('AUTO_REDIRECTED');\n                        }\n                        return config;\n                    });\n            })\n            .then(config => {\n                // Finally, show the banner\n                console.log('[onMessage] Showing banner for:', message.domain);\n                createBanner(\n                    message.bannerMessage || `This resource is available through ${config.institutionLibraryName || 'your library'}. Access the full content via EZProxy.`,\n                    message.ezproxyUrl,\n                    message.domain\n                );\n            })\n            .catch(err => {\n                // These are expected flow control errors, not actual errors\n                if (!['DOMAIN_DISMISSED', 'HAS_INSTITUTIONAL_ACCESS', 'AUTO_REDIRECTED'].includes(err.message)) {\n                    console.error('[onMessage] Error processing domain match:', err);\n                }\n            });\n        \n        // Return true to indicate we'll handle this asynchronously\n        return true;\n    }\n});"],"names":[],"sourceRoot":""}