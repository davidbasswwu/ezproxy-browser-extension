{"version":3,"file":"background.bundle.js","mappings":"AAGA","sources":["webpack://ezproxy-extension/./background.js"],"sourcesContent":["// background.js\n\n// Configuration will be loaded from config.json\nlet CONFIG = null;\nlet DOMAIN_LIST = new Set();\n\n// Constants\nconst MIN_UPDATE_INTERVAL = 60000; // 1 minute\n\n// Cache for transformed URLs to improve performance\nconst urlTransformCache = new Map();\n\nasync function loadConfig() {\n    try {\n        const configUrl = chrome.runtime.getURL('config.json');\n        const response = await fetch(configUrl);\n        if (!response.ok) {\n            throw new Error(`Failed to load configuration: ${response.status}`);\n        }\n        \n        const config = await response.json();\n        \n        // Validate required fields\n        const requiredFields = [\n            'domainListUrl', \n            'ezproxyBaseUrl', \n            'institutionName', \n            'bannerMessage',\n            'updateInterval',\n            'retryAttempts',\n            'retryDelay',\n            'enableAutoRedirect',\n            'enableUserNotifications'\n        ];\n        \n        const missingFields = requiredFields.filter(field => config[field] === undefined);\n        \n        if (missingFields.length > 0) {\n            throw new Error(`Missing required configuration fields: ${missingFields.join(', ')}`);\n        }\n        \n        // Ensure updateInterval is a valid number and meets minimum requirement\n        if (typeof config.updateInterval !== 'number' || config.updateInterval < MIN_UPDATE_INTERVAL) {\n            throw new Error(`updateInterval must be a number >= ${MIN_UPDATE_INTERVAL}ms (1 minute)`);\n        }\n        \n        // Ensure retryAttempts is a valid number\n        if (typeof config.retryAttempts !== 'number' || config.retryAttempts < 0) {\n            throw new Error('retryAttempts must be a non-negative number');\n        }\n        \n        // Ensure retryDelay is a valid number\n        if (typeof config.retryDelay !== 'number' || config.retryDelay < 0) {\n            throw new Error('retryDelay must be a non-negative number');\n        }\n        \n        CONFIG = config;\n        console.log('Configuration loaded successfully');\n        return true;\n    } catch (error) {\n        console.error('Error loading configuration:', error);\n        throw error; // Rethrow to prevent extension from running with invalid config\n    }\n}\n\nasync function loadLocalDomainList() {\n    try {\n        const domainListUrl = chrome.runtime.getURL('domain-list.json');\n        const response = await fetch(domainListUrl);\n        if (!response.ok) {\n            throw new Error(`Failed to load local domain list: ${response.status}`);\n        }\n        const domains = await response.json();\n        \n        // Validate domain list format\n        if (!Array.isArray(domains)) {\n            throw new Error('Domain list must be an array');\n        }\n        \n        return new Set(domains.filter(domain => typeof domain === 'string' && domain.length > 0));\n    } catch (error) {\n        console.error('Error loading local domain list:', error);\n        return new Set(); // Return empty set as last resort\n    }\n}\n\nasync function fetchWithRetry(url, maxRetries = CONFIG.retryAttempts, retryDelay = CONFIG.retryDelay) {\n    let lastError;\n    \n    for (let attempt = 1; attempt <= maxRetries; attempt++) {\n        try {\n            const response = await fetch(url);\n            if (!response.ok) {\n                throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n            }\n            return response;\n        } catch (error) {\n            lastError = error;\n            console.log(`Fetch attempt ${attempt}/${maxRetries} failed:`, error.message);\n            \n            if (attempt < maxRetries) {\n                const delay = retryDelay * Math.pow(2, attempt - 1); // Exponential backoff\n                console.log(`Retrying in ${delay}ms...`);\n                await new Promise(resolve => setTimeout(resolve, delay));\n            }\n        }\n    }\n    \n    throw lastError;\n}\n\nasync function updateDomainList() {\n    try {\n        // Try to load from storage first\n        const stored = await chrome.storage.local.get(['domainList', 'lastUpdate']);\n        if (stored.domainList && Array.isArray(stored.domainList)) {\n            DOMAIN_LIST = new Set(stored.domainList);\n            console.log(`Domain list loaded from storage (${DOMAIN_LIST.size} domains)`);\n            \n            // Check if we need to update based on interval\n            const now = Date.now();\n            const lastUpdate = stored.lastUpdate || 0;\n            const timeSinceUpdate = now - lastUpdate;\n            \n            if (timeSinceUpdate < CONFIG.updateInterval) {\n                console.log(`Domain list is up to date (last updated ${Math.round(timeSinceUpdate / 1000 / 60)} minutes ago)`);\n                return;\n            }\n        }\n\n        // If we get here, we need to fetch a fresh list\n        console.log('Fetching remote domain list from:', CONFIG.domainListUrl);\n        const response = await fetchWithRetry(CONFIG.domainListUrl, CONFIG.retryAttempts, CONFIG.retryDelay);\n        \n        if (!response.ok) {\n            throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n        }\n        \n        const domains = await response.json();\n        \n        // Validate remote domain list\n        if (!Array.isArray(domains)) {\n            throw new Error('Remote domain list is not an array');\n        }\n        \n        const validDomains = domains\n            .filter(domain => typeof domain === 'string' && domain.length > 0)\n            .map(domain => domain.toLowerCase().trim())\n            .filter(domain => {\n                // Basic domain validation\n                try {\n                    new URL(domain.startsWith('http') ? domain : `https://${domain}`);\n                    return true;\n                } catch {\n                    console.warn(`Invalid domain format: ${domain}`);\n                    return false;\n                }\n            });\n            \n        if (validDomains.length === 0) {\n            throw new Error('No valid domains found in the domain list');\n        }\n        \n        DOMAIN_LIST = new Set(validDomains);\n        \n        // Store in local storage for offline access\n        await chrome.storage.local.set({ \n            domainList: Array.from(DOMAIN_LIST),\n            lastUpdate: Date.now()\n        });\n        \n        // Clear URL transform cache when domain list updates\n        urlTransformCache.clear();\n        \n        console.log(`Domain list updated successfully (${DOMAIN_LIST.size} domains)`);\n        return true;\n    } catch (error) {\n        console.error('Error updating domain list:', error);\n        \n        // If we don't have a domain list yet, try to load the local fallback\n        if (DOMAIN_LIST.size === 0) {\n            console.log('Attempting to load local domain list as fallback...');\n            try {\n                const localDomains = await loadLocalDomainList();\n                if (localDomains.size > 0) {\n                    DOMAIN_LIST = localDomains;\n                    console.log(`Loaded ${localDomains.size} domains from local fallback`);\n                    return true;\n                }\n            } catch (localError) {\n                console.error('Error loading local domain list:', localError);\n            }\n            \n            // If we get here, we have no domains at all\n            console.error('CRITICAL: No domain list available (local or remote)');\n            throw new Error('No domain list available. Please check your internet connection and try again.');\n        }\n        \n        // If we have an existing domain list, we can continue using it\n        console.log(`Using existing domain list (${DOMAIN_LIST.size} domains)`);\n        return false;\n    }\n}\n\nfunction transformDomainForEzproxy(domain) {\n    // Use cache to improve performance\n    if (urlTransformCache.has(domain)) {\n        return urlTransformCache.get(domain);\n    }\n    \n    const transformed = domain.replace(/\\./g, '-');\n    urlTransformCache.set(domain, transformed);\n    return transformed;\n}\n\nfunction buildEzproxyUrl(originalUrl, domain) {\n    try {\n        const url = new URL(originalUrl);\n        const transformedDomain = transformDomainForEzproxy(domain);\n        const ezproxyUrl = `${url.protocol}//${transformedDomain}.${CONFIG.ezproxyBaseUrl}${url.pathname}${url.search}${url.hash}`;\n        \n        // Basic URL validation\n        new URL(ezproxyUrl); // Will throw if invalid\n        return ezproxyUrl;\n    } catch (error) {\n        console.error('Error building EZProxy URL:', error);\n        return null;\n    }\n}\n\n// Debounce function for tab updates\nlet tabUpdateTimeout;\nfunction debounceTabUpdate(callback, delay = 100) {\n    clearTimeout(tabUpdateTimeout);\n    tabUpdateTimeout = setTimeout(callback, delay);\n}\n\n// Listen for tab updates to check domain status\nchrome.tabs.onUpdated.addListener(async (tabId, changeInfo, tab) => {\n    if (changeInfo.status === 'complete' && tab.url) {\n        try {\n            // Check if the tab's URL is in the dismissed domains list\n            const url = new URL(tab.url);\n            const domain = url.hostname;\n            \n            // Get the current tab's ID\n            const currentTab = await chrome.tabs.get(tabId);\n            \n            // Check if the domain is dismissed\n            const result = await chrome.storage.local.get('ezproxy-dismissed-domains');\n            const dismissedDomains = result['ezproxy-dismissed-domains'] || [];\n            const isDismissed = dismissedDomains.some(d => \n                domain.endsWith(d) || domain === d\n            );\n            \n            // Update the icon based on the domain's dismissal status\n            await updateExtensionIcon(tabId, isDismissed);\n        } catch (error) {\n            console.error('Error in tab update listener:', error);\n        }\n    }\n});\n\n// Listen for messages from content scripts and popup\nchrome.runtime.onMessage.addListener((request, sender, sendResponse) => {\n    console.log('Received message in background:', request.action || 'unknown action', request);\n    \n    // Handle updateIcon action\n    if (request.action === 'updateIcon') {\n        updateExtensionIcon(request.tabId, request.isDismissed)\n            .then(() => sendResponse({ success: true }))\n            .catch(error => {\n                console.error('Error updating icon:', error);\n                sendResponse({ success: false, error: error.message });\n            });\n        return true; // Required for async response\n    }\n    \n    // Handle dismissDomain action\n    if (request.action === 'dismissDomain') {\n        console.log('Handling dismissDomain for domain:', request.domain);\n        // Get the current active tab to update its icon\n        chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {\n            if (tabs && tabs[0] && tabs[0].id) {\n                console.log('Updating icon for tab:', tabs[0].id);\n                updateExtensionIcon(tabs[0].id, true)\n                    .then(() => {\n                        console.log('Icon updated successfully after domain dismissal');\n                        sendResponse({ success: true });\n                    })\n                    .catch(error => {\n                        console.error('Error updating icon after domain dismissal:', error);\n                        sendResponse({ success: false, error: error.message });\n                    });\n            } else {\n                console.warn('No active tab found to update icon');\n                sendResponse({ success: false, error: 'No active tab found' });\n            }\n        });\n        return true; // Required for async response\n    }\n    \n    // Handle getTab action\n    if (request.action === 'getTab') {\n        chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {\n            sendResponse(tabs);\n        });\n        return true; // Required for async response\n    }\n    \n    // Handle getTabId action\n    if (request.action === 'getTabId') {\n        sendResponse({ tabId: sender.tab ? sender.tab.id : null });\n        return true;\n    }\n    \n    // Handle GET_CONFIG action\n    if (request.type === 'GET_CONFIG') {\n        if (CONFIG) {\n            sendResponse({ config: CONFIG });\n        } else {\n            loadConfig()\n                .then(() => sendResponse({ config: CONFIG }))\n                .catch(error => {\n                    console.error('Error loading config for content script:', error);\n                    sendResponse({ error: 'Failed to load configuration' });\n                });\n        }\n        return true; // Required for async response\n    }\n    \n    // Log unhandled messages for debugging\n    console.warn('Unhandled message in background script:', request);\n    return false;\n});\n\n// Test function to verify icon updates\nasync function testIconUpdate() {\n    console.log('Testing icon update functionality...');\n    \n    // Try to get the current tab\n    const tabs = await chrome.tabs.query({ active: true, currentWindow: true });\n    if (tabs && tabs[0] && tabs[0].id) {\n        const tabId = tabs[0].id;\n        console.log(`Found active tab: ${tabId}`);\n        \n        // Test setting the dismissed icon\n        try {\n            console.log('Setting dismissed icon...');\n            await updateExtensionIcon(tabId, true);\n            console.log('Dismissed icon set successfully');\n            \n            // Set a timeout to reset the icon after 3 seconds\n            setTimeout(async () => {\n                console.log('Resetting to normal icon...');\n                await updateExtensionIcon(tabId, false);\n                console.log('Normal icon restored');\n            }, 3000);\n            \n        } catch (error) {\n            console.error('Error testing icon update:', error);\n        }\n    } else {\n        console.error('No active tab found for testing');\n    }\n}\n\n// Helper function to update the extension icon\nasync function updateExtensionIcon(tabId, isDismissed) {\n    console.log(`[updateExtensionIcon] Updating icon for tab ${tabId}, isDismissed: ${isDismissed}`);\n    \n    // Define icon paths - using chrome.runtime.getURL() for proper resource loading\n    const getIconPath = (size, dismissed = false) => \n        chrome.runtime.getURL(`images/icon${dismissed ? '-dismissed' : ''}-${size}.png`);\n        \n    const icons = {\n        '16': getIconPath(16, isDismissed),\n        '32': getIconPath(32, isDismissed),\n        '48': chrome.runtime.getURL('images/icon-48.png'),\n        '128': chrome.runtime.getURL('images/icon-128.png')\n    };\n    \n    console.log('Using icon paths:', icons);\n    \n    console.log('[updateExtensionIcon] Using icon paths:', icons);\n    \n    // Set the title based on dismissed state\n    const title = isDismissed \n        ? 'EZProxy: Banner is dismissed for this domain'\n        : 'EZProxy: Click to access library resources';\n    \n    try {\n        // First try to update the tab-specific icon\n        if (tabId) {\n            console.log(`[updateExtensionIcon] Updating icon for specific tab ${tabId}`);\n            try {\n                await chrome.action.setIcon({\n                    tabId: tabId,\n                    path: icons\n                });\n                console.log(`[updateExtensionIcon] Successfully updated tab ${tabId} icon`);\n                \n                // Also update the title\n                await chrome.action.setTitle({\n                    tabId: tabId,\n                    title: title\n                });\n                console.log(`[updateExtensionIcon] Set title for tab ${tabId}: ${title}`);\n                \n                // Also update the badge\n                await chrome.action.setBadgeText({\n                    tabId: tabId,\n                    text: isDismissed ? 'X' : ''\n                });\n                \n                await chrome.action.setBadgeBackgroundColor({\n                    tabId: tabId,\n                    color: isDismissed ? '#dc3545' : [0, 0, 0, 0]\n                });\n                \n                return; // Successfully updated tab-specific icon\n                \n            } catch (tabError) {\n                console.error(`[updateExtensionIcon] Error updating tab ${tabId} icon:`, tabError);\n                // Continue to try updating the global icon\n            }\n        }\n        \n        // If we get here, either tabId wasn't provided or tab-specific update failed\n        console.log('[updateExtensionIcon] Updating global icon');\n        await chrome.action.setIcon({\n            tabId: undefined, // Update global icon\n            path: icons\n        });\n        \n        // Update global title\n        await chrome.action.setTitle({\n            tabId: undefined,\n            title: title\n        });\n        \n        console.log('[updateExtensionIcon] Successfully updated global icon and title');\n        \n    } catch (error) {\n        console.error('[updateExtensionIcon] Error in updateExtensionIcon:', error);\n        throw error;\n    }\n}\n\n// Initialize extension\nasync function initialize() {\n    try {\n        console.log('Initializing EZProxy extension...');\n        \n        // Load configuration - will throw if config is invalid\n        await loadConfig();\n        \n        // Load domain list\n        await updateDomainList();\n        \n        // Schedule periodic updates\n        setInterval(updateDomainList, CONFIG.updateInterval);\n        console.log(`Scheduled domain list updates every ${CONFIG.updateInterval / 1000 / 60} minutes`);\n        \n        console.log('EZProxy extension initialized successfully');\n        \n        // Run the icon test\n        setTimeout(testIconUpdate, 1000);\n    } catch (error) {\n        console.error('Fatal error initializing extension:', error);\n        // No fallback - extension requires valid configuration\n        throw error;\n    }\n}\n\n// Start initialization\ninitialize();\n\nchrome.tabs.onUpdated.addListener((tabId, changeInfo, tab) => {\n    // Only process when page is complete and we have a URL\n    if (changeInfo.status !== 'complete' || !tab.url) {\n        return;\n    }\n    \n    // Skip non-HTTP(S) URLs\n    if (!tab.url.startsWith('http://') && !tab.url.startsWith('https://')) {\n        return;\n    }\n    \n    // Debounce rapid tab updates\n    debounceTabUpdate(() => {\n        try {\n            const url = new URL(tab.url);\n            const currentDomain = url.hostname;\n            \n            // Remove 'www.' if it exists\n            const domainWithoutWww = currentDomain.replace(/^www\\./, '');\n            \n            // Check for exact match first\n            let matchedDomain = null;\n            if (DOMAIN_LIST.has(domainWithoutWww)) {\n                matchedDomain = domainWithoutWww;\n            } else {\n                // If not an exact match, check if it's a subdomain of any domain in our list\n                for (const listedDomain of DOMAIN_LIST) {\n                    if (domainWithoutWww.endsWith('.' + listedDomain)) {\n                        matchedDomain = listedDomain;\n                        break;\n                    }\n                }\n            }\n            \n            if (matchedDomain) {\n                console.log('Domain matches tracking list:', matchedDomain, 'for URL:', tab.url);\n                \n                const ezproxyUrl = buildEzproxyUrl(tab.url, matchedDomain);\n                if (!ezproxyUrl) {\n                    console.error('Failed to build EZProxy URL for:', matchedDomain);\n                    return;\n                }\n                \n                // Try sending the message, and if it fails (content script not ready),\n                // retry after a short delay\n                const sendMessageWithRetry = (retryCount = 0) => {\n                    chrome.tabs.sendMessage(tabId, {\n                        type: 'DOMAIN_MATCH',\n                        domain: matchedDomain,\n                        originalUrl: tab.url,\n                        ezproxyUrl: ezproxyUrl,\n                        bannerMessage: CONFIG.bannerMessage\n                    }).catch(error => {\n                        // If content script isn't ready yet, retry a few times\n                        if (error.message.includes('Receiving end does not exist') && retryCount < 3) {\n                            console.log(`Content script not ready, retrying in ${500 * (retryCount + 1)}ms (attempt ${retryCount + 1}/3)`);\n                            setTimeout(() => sendMessageWithRetry(retryCount + 1), 500 * (retryCount + 1));\n                        } else if (!error.message.includes('Receiving end does not exist')) {\n                            console.error('Error sending message to content script:', error);\n                        }\n                    });\n                };\n                \n                sendMessageWithRetry();\n            }\n        } catch (error) {\n            console.error('Error processing URL:', error);\n        }\n    });\n});\n"],"names":[],"sourceRoot":""}