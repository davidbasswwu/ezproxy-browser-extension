{"version":3,"file":"popup.js","mappings":"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","sources":["webpack://ezproxy-extension/./popup.js"],"sourcesContent":["// Constants\nconst STORAGE_KEYS = {\n    DISMISSED_DOMAINS: 'ezproxy-dismissed-domains',\n    AUTO_REDIRECT: 'ezproxy-auto-redirect'\n};\n// Global list of exception domains loaded from domain-list.json\nlet EXCEPTION_DOMAINS = [];\n\n// Get DOM elements\nconst statusDiv = document.getElementById('status');\nconst accessButton = document.getElementById('accessButton');\nconst resetButton = document.getElementById('resetDismissed');\n\n// Check the current tab's status when popup opens\ndocument.addEventListener('DOMContentLoaded', async () => {\n    try {\n        // Set initial status\n        updateStatus('Checking current page...', false);\n        \n        const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });\n        console.log('Current tab:', tab);\n        \n        if (!tab || !tab.url) {\n            console.error('No tab or URL found');\n            updateStatus('Could not access current tab', false);\n            return;\n        }\n        \n        console.log('Checking URL:', tab.url);\n        \n        // Check if current URL is in the domain list or exception list\n        const domainList = await getDomainList();\n        console.log('Domain list loaded, length:', domainList.length, 'Exceptions:', EXCEPTION_DOMAINS.length);\n        \n        if (!domainList || domainList.length === 0) {\n            console.error('Domain list is empty or failed to load');\n            updateStatus('Domain list could not be loaded', false);\n            return;\n        }\n        \n        const currentUrl = new URL(tab.url);\n        console.log('Current hostname:', currentUrl.hostname);\n\n        // Load config for EZProxy base and help URL (ensure defined before using)\n        const config = await (await fetch(chrome.runtime.getURL('config.json'))).json();\n        const ezproxyBaseUrl = config.ezproxyBaseUrl;\n        const libraryHelpUrl = config.libraryHelpUrl;\n        const secondaryHelpButtonText = config.secondaryHelpButtonText || 'Info for this site';\n\n        // Detect if current page is already proxied\n        if (currentUrl.hostname.includes(ezproxyBaseUrl)) {\n            updateStatus('You are already on a proxied page.', true);\n            accessButton.disabled = false;\n            accessButton.textContent = secondaryHelpButtonText;\n            const baseDomain = getBaseDomainFromProxied(currentUrl.hostname, ezproxyBaseUrl);\n            let helpUrl = libraryHelpUrl;\n            if (helpUrl) {\n                helpUrl += (helpUrl.includes('?') ? '&' : '?') + 'q=' + encodeURIComponent(baseDomain);\n            }\n            accessButton.onclick = () => {\n                chrome.tabs.create({ url: helpUrl });\n                window.close();\n            };\n            return;\n        }\n\n        // First, handle exception domains that require special help flow\n        const isExceptionDomain = Array.isArray(EXCEPTION_DOMAINS) && EXCEPTION_DOMAINS.some(ex => currentUrl.hostname.endsWith(ex) || currentUrl.hostname === ex);\n        if (isExceptionDomain) {\n            const baseDomainParts = currentUrl.hostname.split('.');\n            const baseDomain = baseDomainParts.slice(-2).join('.');\n            let helpUrl = libraryHelpUrl;\n            if (helpUrl) {\n                helpUrl += (helpUrl.includes('?') ? '&' : '?') + 'q=' + encodeURIComponent(baseDomain);\n            }\n            updateStatus('This site may require special access. See library help.', true);\n            accessButton.disabled = false;\n            accessButton.textContent = secondaryHelpButtonText;\n            accessButton.onclick = () => {\n                chrome.tabs.create({ url: helpUrl });\n                window.close();\n            };\n            return;\n        }\n        \n        // Check if domain matches any in the list\n        const isDomainInList = domainList.some(domain => {\n            const matches = currentUrl.hostname.endsWith(domain) || currentUrl.hostname === domain;\n            if (matches) console.log('Match found with domain:', domain);\n            return matches;\n        });\n        \n        console.log('Is domain in list:', isDomainInList);\n        \n        if (!isDomainInList) {\n            updateStatus('Current page is not a known library resource', false);\n            return;\n        }\n        \n        // Check if domain is dismissed\n        const result = await chrome.storage.local.get(STORAGE_KEYS.DISMISSED_DOMAINS);\n        const dismissedDomains = result[STORAGE_KEYS.DISMISSED_DOMAINS] || [];\n        console.log('Checking dismissed domains:', dismissedDomains);\n        \n        // Find the specific dismissed domain that matches the current hostname\n        const matchingDismissedDomain = dismissedDomains.find(d => \n            currentUrl.hostname.endsWith(d) || currentUrl.hostname === d\n        );\n        console.log('Matching dismissed domain:', matchingDismissedDomain);\n        \n        const isDismissed = !!matchingDismissedDomain;\n        \n        if (isDismissed) {\n            updateStatus('Banner is currently dismissed for this domain', false);\n            accessButton.disabled = false;\n            accessButton.textContent = 'Show Banner Again';\n            accessButton.onclick = async () => {\n                console.log('Show Banner Again button clicked for domain:', currentUrl.hostname);\n                // Store the matching domain for undismissing\n                const domainToUndismiss = matchingDismissedDomain || currentUrl.hostname;\n                console.log('Will undismiss domain:', domainToUndismiss);\n                await undismissDomain(domainToUndismiss);\n            };\n        } else {\n            updateStatus('This page is a known library resource', true);\n            accessButton.disabled = false;\n            accessButton.onclick = () => redirectToEZProxy(tab.url);\n        }\n    } catch (error) {\n        console.error('Error in popup:', error);\n        updateStatus('Error checking current page', false);\n    }\n});\n\n// Handle reset dismissed domains button\nresetButton.addEventListener('click', async () => {\n    console.log('Reset button clicked');\n    \n    // Show confirmation dialog\n    const confirmed = confirm('Are you sure you want to reset all dismissed domains? This will re-enable the banner for all previously dismissed domains.');\n    \n    if (!confirmed) {\n        console.log('Reset cancelled by user');\n        return;\n    }\n    \n    try {\n        console.log('Starting reset process...');\n        \n        // Save the original button text\n        // Removed unused variable 'originalButtonText' to fix ESLint error\n        \n        // Clear the dismissed domains\n        console.log('Clearing dismissed domains from storage...');\n        await chrome.storage.local.remove(STORAGE_KEYS.DISMISSED_DOMAINS);\n        console.log('Dismissed domains cleared');\n        \n        // Verify the domains were cleared\n        const result = await chrome.storage.local.get(STORAGE_KEYS.DISMISSED_DOMAINS);\n        console.log('Storage after clear:', result);\n        \n        // Update the status\n        updateStatus('Successfully reset all dismissed domains. Reloading page...', true);\n        \n        // Get the current active tab first\n        const [currentTab] = await chrome.tabs.query({ active: true, currentWindow: true });\n        console.log('Current active tab:', currentTab);\n        \n        if (currentTab && currentTab.id) {\n            // Reset the icon for the current tab first\n            console.log(`Updating icon for current tab ${currentTab.id}`);\n            try {\n                await chrome.runtime.sendMessage({\n                    action: 'updateIcon',\n                    tabId: currentTab.id,\n                    isDismissed: false\n                });\n                console.log('Icon updated for current tab');\n            } catch (error) {\n                console.error('Error updating icon for current tab:', error);\n            }\n            \n            // Reload the current tab to show the banner\n            console.log('Reloading current tab...');\n            await chrome.tabs.reload(currentTab.id);\n            console.log('Current tab reloaded');\n        }\n        \n        // Reset icons for all other tabs in the background\n        console.log('Updating icons for all tabs...');\n        const allTabs = await chrome.tabs.query({});\n        for (const tab of allTabs) {\n            if (tab.id && tab.id !== currentTab?.id) {\n                try {\n                    await chrome.runtime.sendMessage({\n                        action: 'updateIcon',\n                        tabId: tab.id,\n                        isDismissed: false\n                    });\n                    console.log(`Updated icon for tab ${tab.id}`);\n                } catch (error) {\n                    console.error(`Error updating icon for tab ${tab.id}:`, error);\n                }\n            }\n        }\n        \n        console.log('Reset process completed');\n        \n        // Close the popup after a short delay\n        setTimeout(() => {\n            console.log('Closing popup...');\n            window.close();\n        }, 1000);\n        \n    } catch (error) {\n        console.error('Error in reset process:', error);\n        updateStatus('Error: ' + (error.message || 'Failed to reset domains'), false);\n        resetButton.disabled = false;\n        resetButton.textContent = 'Try Again';\n    }\n});\n\n// Helper function to update the status display\nfunction updateStatus(message, isActive) {\n    console.log(`Updating status: ${message}, isActive: ${isActive}`);\n    \n    // Make sure the status div exists\n    if (!statusDiv) {\n        console.error('Status div not found in DOM');\n        return;\n    }\n    \n    // Update the text content\n    statusDiv.textContent = message;\n    \n    // Update the class\n    statusDiv.className = `status ${isActive ? 'active' : 'inactive'}`;\n    \n    // Update button state if it exists\n    if (accessButton) {\n        accessButton.disabled = !isActive && message !== 'Banner is currently dismissed for this domain';\n    } else {\n        console.error('Access button not found in DOM');\n    }\n}\n\n// Helper function to get domain list\nasync function getDomainList() {\n    try {\n        console.log('Fetching domain list...');\n        const url = chrome.runtime.getURL('domain-list.json');\n        console.log('Domain list URL:', url);\n        \n        const response = await fetch(url);\n        \n        if (!response.ok) {\n            throw new Error(`Failed to fetch domain list: ${response.status} ${response.statusText}`);\n        }\n        \n        const contentType = response.headers.get('content-type');\n        if (!contentType || !contentType.includes('application/json')) {\n            console.warn('Unexpected content type:', contentType);\n        }\n        \n        const data = await response.json();\n        let domainsArray = [];\n        if (Array.isArray(data)) {\n            domainsArray = data;\n            EXCEPTION_DOMAINS = [];\n        } else if (data && Array.isArray(data.domains)) {\n            domainsArray = data.domains;\n            EXCEPTION_DOMAINS = Array.isArray(data.exceptions) ? data.exceptions : [];\n        }\n        console.log('Domain list loaded successfully, entries:', domainsArray.length, 'Exceptions:', EXCEPTION_DOMAINS.length);\n        return domainsArray;\n    } catch (error) {\n        console.error('Error loading domain list:', error);\n        // Try to load a backup list from storage\n        try {\n            const result = await chrome.storage.local.get('ezproxy-domain-list-backup');\n            const backupList = result['ezproxy-domain-list-backup'];\n            console.log('Using backup domain list from storage:', backupList ? backupList.length : 0, 'entries');\n            return Array.isArray(backupList) ? backupList : [];\n        } catch (storageError) {\n            console.error('Failed to load backup domain list:', storageError);\n            return [];\n        }\n    }\n}\n\n// Helper function to redirect to EZProxy\nasync function redirectToEZProxy(url) {\n    try {\n        const config = await (await fetch(chrome.runtime.getURL('config.json'))).json();\n        \n        // Ensure the target URL is properly formatted\n        let targetUrl = url;\n        if (targetUrl.startsWith('http://')) {\n            targetUrl = targetUrl.substring(7); // Remove http://\n        } else if (targetUrl.startsWith('https://')) {\n            targetUrl = targetUrl.substring(8); // Remove https://\n        }\n        \n        // Ensure the EZProxy base URL ends with a forward slash\n        let ezproxyBase = config.ezproxyBaseUrl;\n        if (!ezproxyBase.endsWith('/')) {\n            ezproxyBase = `${ezproxyBase}/`;\n        }\n        \n        const ezproxyUrl = `${ezproxyBase}${targetUrl}`;\n        console.log('Redirecting to EZProxy URL:', ezproxyUrl);\n        \n        await chrome.tabs.update({ url: ezproxyUrl });\n        window.close();\n    } catch (error) {\n        console.error('Error redirecting to EZProxy:', error);\n        updateStatus('Error redirecting to EZProxy', false);\n    }\n}\n\n// Helper function to undismiss a domain\nasync function undismissDomain(domain) {\n    try {\n        console.log('Undismissing domain:', domain);\n        \n        // Get the current list of dismissed domains\n        const result = await chrome.storage.local.get(STORAGE_KEYS.DISMISSED_DOMAINS);\n        const dismissedDomains = result[STORAGE_KEYS.DISMISSED_DOMAINS] || [];\n        console.log('Current dismissed domains:', dismissedDomains);\n        \n        if (dismissedDomains.length === 0) {\n            console.warn('No dismissed domains found in storage');\n            updateStatus('No dismissed domains found', false);\n            return;\n        }\n        \n        // For debugging, log each domain in the list and check if it matches\n        console.log('Checking each dismissed domain against:', domain);\n        let foundMatches = [];\n        \n        dismissedDomains.forEach(d => {\n            const endsWith = domain.endsWith(d);\n            const exactMatch = domain === d;\n            console.log(`Domain: ${d}, endsWith: ${endsWith}, exactMatch: ${exactMatch}`);\n            \n            if (exactMatch || endsWith) {\n                foundMatches.push(d);\n            }\n        });\n        \n        console.log('Found matching dismissed domains:', foundMatches);\n        \n        if (foundMatches.length === 0) {\n            console.warn('Could not find any matching dismissed domains for:', domain);\n            updateStatus('No matching domains found in dismissed list', false);\n            return;\n        }\n        \n        // Remove all matching domains from the dismissed list\n        const updatedDomains = dismissedDomains.filter(d => !foundMatches.includes(d));\n        console.log('Updated dismissed domains:', updatedDomains);\n        \n        // Save the updated list\n        await chrome.storage.local.set({ [STORAGE_KEYS.DISMISSED_DOMAINS]: updatedDomains });\n        console.log('Saved updated dismissed domains list');\n        \n        // Update the extension icon to show normal state\n        const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });\n        console.log('Current tab:', tab);\n        \n        if (tab && tab.id) {\n            console.log('Sending updateIcon message for tab:', tab.id);\n            try {\n                const response = await chrome.runtime.sendMessage({\n                    action: 'updateIcon',\n                    tabId: tab.id,\n                    isDismissed: false\n                });\n                console.log('Response from updateIcon message:', response);\n            } catch (msgError) {\n                console.error('Error sending updateIcon message:', msgError);\n            }\n            \n            // Update the UI\n            updateStatus('Banner will show again on next visit', true);\n            accessButton.disabled = true;\n            accessButton.textContent = 'Access via EZProxy';\n            \n            // Reload the current tab to show the banner\n            console.log('Reloading tab:', tab.id);\n            await chrome.tabs.reload(tab.id);\n            window.close();\n        }\n    } catch (error) {\n        console.error('Error undismissing domain:', error);\n        updateStatus('Error updating settings', false);\n    }\n}\n\n// Utility to extract the base domain (e.g., chronicle.com) from a proxied hostname (e.g., www-chronicle-com.ezproxy.library.wwu.edu)\nfunction getBaseDomainFromProxied(hostname, ezproxyBaseUrl) {\n    // Remove the ezproxy part\n    const proxiedPart = hostname.replace('.' + ezproxyBaseUrl, '');\n    // Convert dashes to dots\n    const original = proxiedPart.replace(/-/g, '.');\n    // Return last two parts (base domain)\n    const parts = original.split('.');\n    if (parts.length <= 2) return original;\n    return parts.slice(-2).join('.');\n}\n"],"names":["STORAGE_KEYS","EXCEPTION_DOMAINS","statusDiv","document","getElementById","accessButton","resetButton","updateStatus","message","isActive","textContent","className","disabled","addEventListener","async","tab","chrome","tabs","query","active","currentWindow","url","domainList","runtime","getURL","response","fetch","ok","Error","status","statusText","contentType","headers","get","includes","data","json","domainsArray","Array","isArray","domains","exceptions","error","backupList","storage","local","storageError","getDomainList","length","currentUrl","URL","config","ezproxyBaseUrl","libraryHelpUrl","secondaryHelpButtonText","hostname","baseDomain","proxiedPart","replace","original","parts","split","slice","join","getBaseDomainFromProxied","helpUrl","encodeURIComponent","onclick","create","window","close","some","ex","endsWith","domain","matches","result","matchingDismissedDomain","find","d","domainToUndismiss","dismissedDomains","foundMatches","forEach","push","updatedDomains","filter","set","id","sendMessage","action","tabId","isDismissed","msgError","reload","undismissDomain","targetUrl","startsWith","substring","ezproxyBase","ezproxyUrl","update","redirectToEZProxy","confirm","remove","currentTab","allTabs","setTimeout"],"sourceRoot":""}