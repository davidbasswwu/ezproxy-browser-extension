{"version":3,"file":"background.js","mappings":"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","sources":["webpack://ezproxy-extension/./background.js"],"sourcesContent":["// background.js\n\n// Configuration will be loaded from config.json\nlet CONFIG = null;\nlet DOMAIN_LIST = new Set();\n\n// Constants\nconst MIN_UPDATE_INTERVAL = 60000; // 1 minute\n\n// Cache for transformed URLs to improve performance\nconst urlTransformCache = new Map();\n\nasync function loadConfig() {\n    try {\n        const configUrl = chrome.runtime.getURL('config.json');\n        const response = await fetch(configUrl);\n        if (!response.ok) {\n            throw new Error(`Failed to load configuration: ${response.status}`);\n        }\n        \n        const config = await response.json();\n        \n        // Validate required fields\n        const requiredFields = [\n            'domainListUrl', \n            'ezproxyBaseUrl', \n            'institutionName', \n            'bannerMessage',\n            'updateInterval',\n            'retryAttempts',\n            'retryDelay',\n            'enableAutoRedirect',\n            'enableUserNotifications'\n        ];\n        \n        const missingFields = requiredFields.filter(field => config[field] === undefined);\n        \n        if (missingFields.length > 0) {\n            throw new Error(`Missing required configuration fields: ${missingFields.join(', ')}`);\n        }\n        \n        // Ensure updateInterval is a valid number and meets minimum requirement\n        if (typeof config.updateInterval !== 'number' || config.updateInterval < MIN_UPDATE_INTERVAL) {\n            throw new Error(`updateInterval must be a number >= ${MIN_UPDATE_INTERVAL}ms (1 minute)`);\n        }\n        \n        // Ensure retryAttempts is a valid number\n        if (typeof config.retryAttempts !== 'number' || config.retryAttempts < 0) {\n            throw new Error('retryAttempts must be a non-negative number');\n        }\n        \n        // Ensure retryDelay is a valid number\n        if (typeof config.retryDelay !== 'number' || config.retryDelay < 0) {\n            throw new Error('retryDelay must be a non-negative number');\n        }\n        \n        CONFIG = config;\n        console.log('Configuration loaded successfully');\n        return true;\n    } catch (error) {\n        console.error('Error loading configuration:', error);\n        throw error; // Rethrow to prevent extension from running with invalid config\n    }\n}\n\nasync function loadLocalDomainList() {\n    try {\n        const domainListUrl = chrome.runtime.getURL('domain-list.json');\n        const response = await fetch(domainListUrl);\n        if (!response.ok) {\n            throw new Error(`Failed to load local domain list: ${response.status}`);\n        }\n        const domains = await response.json();\n        \n        // Validate domain list format\n        if (!Array.isArray(domains)) {\n            throw new Error('Domain list must be an array');\n        }\n        \n        return new Set(domains.filter(domain => typeof domain === 'string' && domain.length > 0));\n    } catch (error) {\n        console.error('Error loading local domain list:', error);\n        return new Set(); // Return empty set as last resort\n    }\n}\n\nasync function fetchWithRetry(url, maxRetries = CONFIG.retryAttempts, retryDelay = CONFIG.retryDelay) {\n    let lastError;\n    \n    for (let attempt = 1; attempt <= maxRetries; attempt++) {\n        try {\n            const response = await fetch(url);\n            if (!response.ok) {\n                throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n            }\n            return response;\n        } catch (error) {\n            lastError = error;\n            console.log(`Fetch attempt ${attempt}/${maxRetries} failed:`, error.message);\n            \n            if (attempt < maxRetries) {\n                const delay = retryDelay * Math.pow(2, attempt - 1); // Exponential backoff\n                console.log(`Retrying in ${delay}ms...`);\n                await new Promise(resolve => setTimeout(resolve, delay));\n            }\n        }\n    }\n    \n    throw lastError;\n}\n\nasync function updateDomainList() {\n    try {\n        // Try to load from storage first\n        const stored = await chrome.storage.local.get(['domainList', 'lastUpdate']);\n        if (stored.domainList && Array.isArray(stored.domainList)) {\n            DOMAIN_LIST = new Set(stored.domainList);\n            console.log(`Domain list loaded from storage (${DOMAIN_LIST.size} domains)`);\n            \n            // Check if we need to update based on interval\n            const now = Date.now();\n            const lastUpdate = stored.lastUpdate || 0;\n            const timeSinceUpdate = now - lastUpdate;\n            \n            if (timeSinceUpdate < CONFIG.updateInterval) {\n                console.log(`Domain list is up to date (last updated ${Math.round(timeSinceUpdate / 1000 / 60)} minutes ago)`);\n                return;\n            }\n        }\n\n        // If we get here, we need to fetch a fresh list\n        console.log('Fetching remote domain list from:', CONFIG.domainListUrl);\n        const response = await fetchWithRetry(CONFIG.domainListUrl, CONFIG.retryAttempts, CONFIG.retryDelay);\n        \n        if (!response.ok) {\n            throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n        }\n        \n        const domains = await response.json();\n        \n        // Validate remote domain list\n        if (!Array.isArray(domains)) {\n            throw new Error('Remote domain list is not an array');\n        }\n        \n        const validDomains = domains\n            .filter(domain => typeof domain === 'string' && domain.length > 0)\n            .map(domain => domain.toLowerCase().trim())\n            .filter(domain => {\n                // Basic domain validation\n                try {\n                    new URL(domain.startsWith('http') ? domain : `https://${domain}`);\n                    return true;\n                } catch {\n                    console.warn(`Invalid domain format: ${domain}`);\n                    return false;\n                }\n            });\n            \n        if (validDomains.length === 0) {\n            throw new Error('No valid domains found in the domain list');\n        }\n        \n        DOMAIN_LIST = new Set(validDomains);\n        \n        // Store in local storage for offline access\n        await chrome.storage.local.set({ \n            domainList: Array.from(DOMAIN_LIST),\n            lastUpdate: Date.now()\n        });\n        \n        // Clear URL transform cache when domain list updates\n        urlTransformCache.clear();\n        \n        console.log(`Domain list updated successfully (${DOMAIN_LIST.size} domains)`);\n        return true;\n    } catch (error) {\n        console.error('Error updating domain list:', error);\n        \n        // If we don't have a domain list yet, try to load the local fallback\n        if (DOMAIN_LIST.size === 0) {\n            console.log('Attempting to load local domain list as fallback...');\n            try {\n                const localDomains = await loadLocalDomainList();\n                if (localDomains.size > 0) {\n                    DOMAIN_LIST = localDomains;\n                    console.log(`Loaded ${localDomains.size} domains from local fallback`);\n                    return true;\n                }\n            } catch (localError) {\n                console.error('Error loading local domain list:', localError);\n            }\n            \n            // If we get here, we have no domains at all\n            console.error('CRITICAL: No domain list available (local or remote)');\n            throw new Error('No domain list available. Please check your internet connection and try again.');\n        }\n        \n        // If we have an existing domain list, we can continue using it\n        console.log(`Using existing domain list (${DOMAIN_LIST.size} domains)`);\n        return false;\n    }\n}\n\nfunction transformDomainForEzproxy(domain) {\n    // Use cache to improve performance\n    if (urlTransformCache.has(domain)) {\n        return urlTransformCache.get(domain);\n    }\n    \n    const transformed = domain.replace(/\\./g, '-');\n    urlTransformCache.set(domain, transformed);\n    return transformed;\n}\n\nfunction buildEzproxyUrl(originalUrl, domain) {\n    try {\n        const url = new URL(originalUrl);\n        const transformedDomain = transformDomainForEzproxy(domain);\n        const ezproxyUrl = `${url.protocol}//${transformedDomain}.${CONFIG.ezproxyBaseUrl}${url.pathname}${url.search}${url.hash}`;\n        \n        // Basic URL validation\n        new URL(ezproxyUrl); // Will throw if invalid\n        return ezproxyUrl;\n    } catch (error) {\n        console.error('Error building EZProxy URL:', error);\n        return null;\n    }\n}\n\n// Debounce function for tab updates\nlet tabUpdateTimeout;\nfunction debounceTabUpdate(callback, delay = 100) {\n    clearTimeout(tabUpdateTimeout);\n    tabUpdateTimeout = setTimeout(callback, delay);\n}\n\n// Listen for tab updates to check domain status\nchrome.tabs.onUpdated.addListener(async (tabId, changeInfo, tab) => {\n    if (changeInfo.status === 'complete' && tab.url) {\n        try {\n            // Check if the tab's URL is in the dismissed domains list\n            const url = new URL(tab.url);\n            const domain = url.hostname;\n            \n            // Get the current tab's ID\n            // Removed unused variable 'currentTab' to fix ESLint error\n            \n            // Check if the domain is dismissed\n            const result = await chrome.storage.local.get('ezproxy-dismissed-domains');\n            const dismissedDomains = result['ezproxy-dismissed-domains'] || [];\n            const isDismissed = dismissedDomains.some(d => \n                domain.endsWith(d) || domain === d\n            );\n            \n            // Update the icon based on the domain's dismissal status\n            await updateExtensionIcon(tabId, isDismissed);\n        } catch (error) {\n            console.error('Error in tab update listener:', error);\n        }\n    }\n});\n\n// Listen for messages from content scripts and popup\nchrome.runtime.onMessage.addListener((request, sender, sendResponse) => {\n    console.log('Received message in background:', request.action || 'unknown action', request);\n    \n    // Handle updateIcon action\n    if (request.action === 'updateIcon') {\n        updateExtensionIcon(request.tabId, request.isDismissed)\n            .then(() => sendResponse({ success: true }))\n            .catch(error => {\n                console.error('Error updating icon:', error);\n                sendResponse({ success: false, error: error.message });\n            });\n        return true; // Required for async response\n    }\n    \n    // Handle dismissDomain action\n    if (request.action === 'dismissDomain') {\n        console.log('Handling dismissDomain for domain:', request.domain);\n        // Get the current active tab to update its icon\n        chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {\n            if (tabs && tabs[0] && tabs[0].id) {\n                console.log('Updating icon for tab:', tabs[0].id);\n                updateExtensionIcon(tabs[0].id, true)\n                    .then(() => {\n                        console.log('Icon updated successfully after domain dismissal');\n                        sendResponse({ success: true });\n                    })\n                    .catch(error => {\n                        console.error('Error updating icon after domain dismissal:', error);\n                        sendResponse({ success: false, error: error.message });\n                    });\n            } else {\n                console.warn('No active tab found to update icon');\n                sendResponse({ success: false, error: 'No active tab found' });\n            }\n        });\n        return true; // Required for async response\n    }\n    \n    // Handle getTab action\n    if (request.action === 'getTab') {\n        chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {\n            sendResponse(tabs);\n        });\n        return true; // Required for async response\n    }\n    \n    // Handle getTabId action\n    if (request.action === 'getTabId') {\n        sendResponse({ tabId: sender.tab ? sender.tab.id : null });\n        return true;\n    }\n    \n    // Handle GET_CONFIG action\n    if (request.type === 'GET_CONFIG') {\n        if (CONFIG) {\n            sendResponse({ config: CONFIG });\n        } else {\n            loadConfig()\n                .then(() => sendResponse({ config: CONFIG }))\n                .catch(error => {\n                    console.error('Error loading config for content script:', error);\n                    sendResponse({ error: 'Failed to load configuration' });\n                });\n        }\n        return true; // Required for async response\n    }\n    \n    // Log unhandled messages for debugging\n    console.warn('Unhandled message in background script:', request);\n    return false;\n});\n\n// Test function to verify icon updates\nasync function testIconUpdate() {\n    console.log('Testing icon update functionality...');\n    \n    // Try to get the current tab\n    const tabs = await chrome.tabs.query({ active: true, currentWindow: true });\n    if (tabs && tabs[0] && tabs[0].id) {\n        const tabId = tabs[0].id;\n        console.log(`Found active tab: ${tabId}`);\n        \n        // Test setting the dismissed icon\n        try {\n            console.log('Setting dismissed icon...');\n            await updateExtensionIcon(tabId, true);\n            console.log('Dismissed icon set successfully');\n            \n            // Set a timeout to reset the icon after 3 seconds\n            setTimeout(async () => {\n                console.log('Resetting to normal icon...');\n                await updateExtensionIcon(tabId, false);\n                console.log('Normal icon restored');\n            }, 3000);\n            \n        } catch (error) {\n            console.error('Error testing icon update:', error);\n        }\n    } else {\n        console.error('No active tab found for testing');\n    }\n}\n\n// Helper function to update the extension icon\nasync function updateExtensionIcon(tabId, isDismissed) {\n    console.log(`[updateExtensionIcon] Updating icon for tab ${tabId}, isDismissed: ${isDismissed}`);\n    \n    // Define icon paths - using chrome.runtime.getURL() for proper resource loading\n    const getIconPath = (size, dismissed = false) => \n        chrome.runtime.getURL(`images/icon${dismissed ? '-dismissed' : ''}-${size}.png`);\n        \n    const icons = {\n        '16': getIconPath(16, isDismissed),\n        '32': getIconPath(32, isDismissed),\n        '48': chrome.runtime.getURL('images/icon-48.png'),\n        '128': chrome.runtime.getURL('images/icon-128.png')\n    };\n    \n    console.log('Using icon paths:', icons);\n    \n    console.log('[updateExtensionIcon] Using icon paths:', icons);\n    \n    // Set the title based on dismissed state\n    const title = isDismissed \n        ? 'EZProxy: Banner is dismissed for this domain'\n        : 'EZProxy: Click to access library resources';\n    \n    try {\n        // First try to update the tab-specific icon\n        if (tabId) {\n            console.log(`[updateExtensionIcon] Updating icon for specific tab ${tabId}`);\n            try {\n                await chrome.action.setIcon({\n                    tabId: tabId,\n                    path: icons\n                });\n                console.log(`[updateExtensionIcon] Successfully updated tab ${tabId} icon`);\n                \n                // Also update the title\n                await chrome.action.setTitle({\n                    tabId: tabId,\n                    title: title\n                });\n                console.log(`[updateExtensionIcon] Set title for tab ${tabId}: ${title}`);\n                \n                // Also update the badge\n                await chrome.action.setBadgeText({\n                    tabId: tabId,\n                    text: isDismissed ? 'X' : ''\n                });\n                \n                await chrome.action.setBadgeBackgroundColor({\n                    tabId: tabId,\n                    color: isDismissed ? '#dc3545' : [0, 0, 0, 0]\n                });\n                \n                return; // Successfully updated tab-specific icon\n                \n            } catch (tabError) {\n                console.error(`[updateExtensionIcon] Error updating tab ${tabId} icon:`, tabError);\n                // Continue to try updating the global icon\n            }\n        }\n        \n        // If we get here, either tabId wasn't provided or tab-specific update failed\n        console.log('[updateExtensionIcon] Updating global icon');\n        await chrome.action.setIcon({\n            tabId: undefined, // Update global icon\n            path: icons\n        });\n        \n        // Update global title\n        await chrome.action.setTitle({\n            tabId: undefined,\n            title: title\n        });\n        \n        console.log('[updateExtensionIcon] Successfully updated global icon and title');\n        \n    } catch (error) {\n        console.error('[updateExtensionIcon] Error in updateExtensionIcon:', error);\n        throw error;\n    }\n}\n\n// Initialize extension\nasync function initialize() {\n    try {\n        console.log('Initializing EZProxy extension...');\n        \n        // Load configuration - will throw if config is invalid\n        await loadConfig();\n        \n        // Load domain list\n        await updateDomainList();\n        \n        // Schedule periodic updates\n        setInterval(updateDomainList, CONFIG.updateInterval);\n        console.log(`Scheduled domain list updates every ${CONFIG.updateInterval / 1000 / 60} minutes`);\n        \n        console.log('EZProxy extension initialized successfully');\n        \n        // Run the icon test\n        setTimeout(testIconUpdate, 1000);\n    } catch (error) {\n        console.error('Fatal error initializing extension:', error);\n        // No fallback - extension requires valid configuration\n        throw error;\n    }\n}\n\n// Start initialization\ninitialize();\n\nchrome.tabs.onUpdated.addListener((tabId, changeInfo, tab) => {\n    // Only process when page is complete and we have a URL\n    if (changeInfo.status !== 'complete' || !tab.url) {\n        return;\n    }\n    \n    // Skip non-HTTP(S) URLs\n    if (!tab.url.startsWith('http://') && !tab.url.startsWith('https://')) {\n        return;\n    }\n    \n    // Debounce rapid tab updates\n    debounceTabUpdate(() => {\n        try {\n            const url = new URL(tab.url);\n            const currentDomain = url.hostname;\n            \n            // Remove 'www.' if it exists\n            const domainWithoutWww = currentDomain.replace(/^www\\./, '');\n            \n            // Check for exact match first\n            let matchedDomain = null;\n            if (DOMAIN_LIST.has(domainWithoutWww)) {\n                matchedDomain = domainWithoutWww;\n            } else {\n                // If not an exact match, check if it's a subdomain of any domain in our list\n                for (const listedDomain of DOMAIN_LIST) {\n                    if (domainWithoutWww.endsWith('.' + listedDomain)) {\n                        matchedDomain = listedDomain;\n                        break;\n                    }\n                }\n            }\n            \n            if (matchedDomain) {\n                console.log('Domain matches tracking list:', matchedDomain, 'for URL:', tab.url);\n                \n                const ezproxyUrl = buildEzproxyUrl(tab.url, matchedDomain);\n                if (!ezproxyUrl) {\n                    console.error('Failed to build EZProxy URL for:', matchedDomain);\n                    return;\n                }\n                \n                // Try sending the message, and if it fails (content script not ready),\n                // retry after a short delay\n                const sendMessageWithRetry = (retryCount = 0) => {\n                    chrome.tabs.sendMessage(tabId, {\n                        type: 'DOMAIN_MATCH',\n                        domain: matchedDomain,\n                        originalUrl: tab.url,\n                        ezproxyUrl: ezproxyUrl,\n                        bannerMessage: CONFIG.bannerMessage\n                    }).catch(error => {\n                        // If content script isn't ready yet, retry a few times\n                        if (error.message.includes('Receiving end does not exist') && retryCount < 3) {\n                            console.log(`Content script not ready, retrying in ${500 * (retryCount + 1)}ms (attempt ${retryCount + 1}/3)`);\n                            setTimeout(() => sendMessageWithRetry(retryCount + 1), 500 * (retryCount + 1));\n                        } else if (!error.message.includes('Receiving end does not exist')) {\n                            console.error('Error sending message to content script:', error);\n                        }\n                    });\n                };\n                \n                sendMessageWithRetry();\n            }\n        } catch (error) {\n            console.error('Error processing URL:', error);\n        }\n    });\n});\n"],"names":["CONFIG","DOMAIN_LIST","Set","urlTransformCache","Map","async","loadConfig","configUrl","chrome","runtime","getURL","response","fetch","ok","Error","status","config","json","missingFields","filter","field","undefined","length","join","updateInterval","retryAttempts","retryDelay","error","updateDomainList","stored","storage","local","get","domainList","Array","isArray","now","Date","lastUpdate","url","maxRetries","lastError","attempt","statusText","delay","Math","pow","Promise","resolve","setTimeout","fetchWithRetry","domainListUrl","domains","validDomains","domain","map","toLowerCase","trim","URL","startsWith","set","from","clear","size","localDomains","loadLocalDomainList","localError","buildEzproxyUrl","originalUrl","transformedDomain","has","transformed","replace","transformDomainForEzproxy","ezproxyUrl","protocol","ezproxyBaseUrl","pathname","search","hash","tabUpdateTimeout","testIconUpdate","tabs","query","active","currentWindow","id","tabId","updateExtensionIcon","isDismissed","getIconPath","dismissed","icons","title","action","setIcon","path","setTitle","setBadgeText","text","setBadgeBackgroundColor","color","tabError","onUpdated","addListener","changeInfo","tab","hostname","result","some","d","endsWith","onMessage","request","sender","sendResponse","then","success","catch","message","type","setInterval","initialize","callback","clearTimeout","debounceTabUpdate","domainWithoutWww","matchedDomain","listedDomain","sendMessageWithRetry","retryCount","sendMessage","bannerMessage","includes"],"sourceRoot":""}